{"./":{"url":"./","title":"À propos de cette documentation","keywords":"","body":" Documentation du projet Poppy Bienvenue dans la documentation du Projet Poppy, une plate-forme de robotique open-source. Cette documentation est organisée comme suit: Premiers pas: un aperçu de comment peut s'utiliser un robot Poppy assemblé et ce qu'on peut faire avec Guides d'assemblage: certainement la prochaine section à lire si avez hâte d'assembler votre nouveau robot ! Installation: une explicaiton plus en profondeur du logiciel, pour voir comment il peut être utilisé dans tous les cas d'usage possibles Programmation: une explication plus en profondeur des langages de programmation de Poppy et de ses interfaces de communication À propos et contributions Cette documentation est maintenue par l’équipe Poppy avec l'aide de nombreux contributeurs. Sentez-vous libres de contribuer ! Ce document est sous licence CC-BY 4.0. Vous êtes libre de copier, modifier et redistribuer ce document tant que vous donnez un crédit approprié aux auteurs et un lien vers le site original docs.poppy-Project.org. Version Ce document a été mis à jour le 24/12/2020. Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"getting-started/":{"url":"getting-started/","title":"Premiers pas","keywords":"","body":"Premiers pas Le projet de Poppy est une plate-forme open-source pour la création, l'utilisation et le partage de robots interactifs imprimés en 3D. Il rassemble une communauté interdisciplinaire de débutants, d'experts, de chercheurs, d'enseignants, de développeurs et d'artistes. Ils partagent tous une même vision : les robots sont de puissants outils pour apprendre et développer la créativité, et ils collaborent pour améliorer le projet. Ils développent de nouveaux comportements pour les robots, créent des contenus pédagogiques, élaborent des performances artistiques, améliorent le logiciel ou même conçoivent de nouveaux robots. La communauté Poppy développe des créations robotiques qui sont faciles à construire, personnaliser et utiliser. Un ensemble de services web permet à la communauté de partager leurs expériences et de contribuer à l'amélioration de la plateforme Poppy. Pour faciliter ces échanges, deux supports sont disponibles : Le forum de projet Poppy pour avoir de l'aide, partager ses idées et en discuter. GitHub pour soumettre vos contributions et faire un suivi des bugs logiciels. Toutes les sources du projet Poppy (logiciel et matériel) sont disponibles sur GitHub. Le projet Poppy a été conçu initialement à Inria dans l'équipe Flowers. Les robots Poppy Les robots Poppy sont open source et libre. Leur sources sont disponible librement, il est possible de les modifier et de les redistribuer selon les termes prévus par leur licenses. Les pièces matérielles (carte électronique et modélisation 3D) sont sous license (Creative Commons Attribution-ShareAlike et le logiciel GPLv3. Ils ont été tous conçus selon les même principes. Les robots Poppy: sont fabriqués à partir de pièces imprimable en 3D et des servomoteurs Dynamixel, utilisent un ordinateur embarqué (Raspberry Pi ou Odroid pour les anciennes versions), fonctionnent avec une bibliothèque logicielle en Python, pypot, qui permet de contrôler les servomoteurs Dynamixel simplement, sont également contrôlable avec les même outils dans un simulateur ( CoppeliaSim), peuvent être contrôlé à l’aide d’un langage de programmation visuel (Snap ! une variante de Scratch) et un langage textuel Python. Ils sont également programmables via une API REST, ce qui permet se s'interfacer avec d'autres languages de programmation viennent avec un documentation associée, des tutoriels, des exemples et des activités pédagogiques. Ils peuvent être utilisés comme tels quels ou hackés (au sens de bidouillé) pour explorer de nouvelles formes, ajouter des capteurs, etc... Pour obtenir votre propre robot Poppy, vous pouvez soit : vous procurer toutes les pièces en suivant la liste du matériel (voir ci-dessous). Acheter un des robots Poppy en kit complet chez notre revendeur officiel, Génération Robots. Poppy Ergo Jr Le robot Poppy Ergo Jr est un petit bras robot à faible coût avec dôté de 6 articulations. Il est fait de 6 moteurs peu cher (XL-320 servomoteurs Dynamixel servos) avec des pièces simples imprimés 3D. Les pièces 3D ont été conçues pour être facilement imprimable sur une imprimante 3D basique. Les moteurs coûtent seulement 20€ chacun. L'accès à sa carte électronique est simple. Elle facilite la connexion des capteurs supplémentaires et est bien adaptée à des fins pédagogiques. Vous pouvez choisir parmi trois outils à la fin de son bras : Un abat-jour. Une pince. Un porte stylo. Les rivets utilisés rendent le changement d'outil simple à faire. Vous pouvez l’adapter selon le type d’activités que vous faites. Poppy Ergo Jr est le robot idéal pour apprendre la robotique sans difficultés : assemblage simple, facile à contrôler et à un prix abordable. Vous pouvez vous procurez toutes les pièces en suivant la nomenclature (BOM) et imprimer les pièces 3D disponible au format STL. Pour plus d'informations, jetez un coup d'oeil au guide d'assemblage de l'Ergo Jr. Poppy Humanoid C’est un robot humanoïde composé de 25 articulations avec une colonne vertébrale entièrement actionnée. Il est utilisé pour l'éducation, la recherche (étude de la marche, l’interaction Homme-robot) ou encore pour des performances artistiques. D'un bras au robot complet, cette plateforme est activement utilisée dans les laboratoires, les écoles d'ingénieur, les fablabs et les projets artistiques. Vous pouvez vous procurez toutes les pièces en suivant la nomenclature (BOM) et imprimer les pièces 3D disponible au format STL. Poppy Torso C'est la partie supérieure du robot Poppy Humanoid (13 articulations). Poppy Torso est donc plus abordable qu'un Poppy Humanoid. Ce robot offre une solution plus adaptée aux besoins de l'éducation, des associations et des bricoleurs. Poppy Torso peut être un bon moyen pour apprendre les sciences, les technologies de l'information, l’ingénierie et les mathématiques (STIM). Vous pouvez vous procurez toutes les pièces en suivant la nomenclature. Les modèles 3D pour les pièces sont les mêmes que pour Poppy Humanoid, mais sans les jambes et avec un support ventouse en plus. Autres créatures Poppy intéressantes Un aspect clé du projet Poppy est de stimuler la créativité et l’expérimentation autour de la robotique. Nous essayons de fournir tous les outils nécessaires pour concevoir de nouveaux robots basées sur les mêmes briques technologiques. Quelques nouvelles créatures sont en développement au sein de la communauté. Certaines d'entre elles sont illustrées ci-dessous. Poppy bras droit (travail en cours) Poppy bras droit est une créature Poppy basé sur le bras droit du robot Poppy Humanoid, avec 3 moteurs XL-320 supplémentaires pour améliorer la portée et l'agitilité du bras. Il utilise le même outil de préhension utilisé par l’Ergo Jr, conçu pour attraper des objets simples. Le projet a été réalisé lors d’un stage au sein de l'équipe Flowers de l'Inria par Joel Ortiz Sosa. Pour plus d'informations et les sources jetez un coup d'oeil au répertoire. Des Humanoid plus petits et moins chers Heol Heol - « soleil » en Breton - est un robot humanoïde haut de 34cm fait par l’association Heol robotique. Composé de 23 moteurs, toutes les autres pièces sont imprimés en 3D. Il utilise également la bibliothèque pypot pour ses mouvements. Le but de Heol est de donner le sourire aux enfants malades. Il peut être un outil pédagogique en devenant une plateforme d'apprentissage pour la conception mécanique et de programmation. Sa participation à la RoboCup (coupe du monde de football pour robots) est également envisagée. Poppyrate C'est un robot basé sur le Poppy Humanoid. Il vise à développer une version plus abordable grâce à sa petite taille et l’utilisation de moteurs encore moins chers. La réduction de la taille rend également plus facile l'impression des pièces avec une imprimante 3D standard. L'objectif donné est de rendre le robot aussi mobile et customisable que possible tout en maintenant sa compatibilité avec la plateforme Poppy. Poppyrate sera vendu en kit (avec ou sans les pièces 3D). Il a été conçu par l'entreprise ZeCloud. Pour plus d’informations, consultez leur Twitter - Facebook ! Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"getting-started/connect.html":{"url":"getting-started/connect.html","title":"Se connecter au robot","keywords":"","body":"Démarrez et connectez le robot Dans cette section, nous décrirons comment démarrer votre robot et donnerons un aperçu des possibilités d’y accéder. Configurer le logiciel Les robots Poppy sont équipés d'une carte embarquée (exemple : Raspberry Pi, ODROID...) dont le rôle consiste à contrôler les moteurs et à accéder aux capteurs. À des fin de simplicité, on peut accéder à cet ordinateur à distance via une interface web. Il est facile de contrôler le robot à partir de votre propre ordinateur ou tablette sans avoir à télécharger / installer quoi que ce soit. Il existe deux façons de configurer la carte pour votre robot Poppy: la manière simple : utilisez une image préprogrammée du système d'exploitation Poppy et écrivez-la (installez-la) sur la carte SD la manière difficile pour les utilisateurs avancés : installez tout à partir de zéro Note Si vous envisagez d'utiliser un robot simulé (robot virtuel), vous devez installer le logiciel sur votre ordinateur personnel. Suivez les instructions pour le paramétrage de la simulation. Manière simple et recommandée : utiliser la carte SD Poppy Le moyen le plus simple et le plus rapide - de loin - est d'utiliser une image système déjà créée pour une carte SD. Les images ISO contiennent tous les éléments pré-installés pour votre robot Poppy. C'est aussi un bon moyen de s'assurer que vous utilisez exactement le même logiciel que nous. Ainsi, vous éviterez la plupart des problèmes. Note Les kits robotiques Poppy sont livrés avec une carte SD prête à l'emploi. Donc, vous n'avez rien de spécial à faire. Pour chaque robot Poppy, l'image se trouve sur sa page web de sa dernière version : pour le robot Poppy Ergo Jr pour le robot Poppy Torso pour le robot Poppy Humanoid L'image peut être écrite sur une carte SD (d'au moins 8 Go) en utilisant un utilitaire tel qu'Etcher. Une fois que la carte SD est prête, insérez-la dans la carte embarquée (micro-ordinateur). Ensuite, lorsque vous branchez votre robot, il devrait démarrer automatiquement et vous devriez pouvoir vous connecter à son interface web. Info Vous trouverez plus de détails dans la section démarrage. Manière avancée : DIY, installez tout à partir de zéro La manière avancée consiste principalement à installer tout ce qui est nécessaire à partir de zéro. Cela suit la même procédure que nous utilisons pour générer l'image de cartes SD. Nous mentionnons cette possibilité ici car cela peut être utile si : Vous travaillez avec un robot simulé et devez donc installer manuellement tous les logiciels requis sur votre ordinateur, cette procédure vous montre comment cela peut être fait sur un Raspberry-Pi (carte embarquée) et l'adapter à un autre ordinateur, vous voulez personnaliser l'environnement, ou si vous voulez tout simplement comprendre comment ça fonctionne. Attention Nous essayons de garder cette procédure d'installation aussi générique que possible. Pourtant, certains détails peuvent varier selon votre système d'exploitation ou votre ordinateur. En outre, l'installation à partir de zéro exige une bonne connaissance de comment installer et configurer un environnement python. Selon ce que vous voulez faire, toutes les étapes ne sont pas nécessaires. En particulier, si vous souhaitez contrôler un robot simulé, vous pouvez simplement installer les bibliothèques python pour Poppy. Information Plus de détails peuvent être trouvés dans la section Installation pour utilisateurs avancés. Configuration du réseau Wifi ou Ethernet Une fois que votre Poppy est assemblé et son logiciel est prêt, l'étape suivante consiste à le connecter à un réseau. L'objectif est de vous permettre d'accéder à distance au robot à partir de votre ordinateur ou votre smartphone / tablette, le contrôler et le programmer. Il y a 4 méthodes principales de connecter votre robot à votre ordinateur / tablette / smartphone : Connecter votre ordinateur en Wifi au hotspot du robot Poppy-Hotspot, avec la clé Wifi poppyproject (le plus facile, mais ne donne pas accès à Internet) Connecter votre robot en Wifi à votre routeur (par exemple, la box internet de votre maison ou le réseau de l'école). Cela nécessite néanmoins d'avoir une première fois accès à l'interface de réglages du robot via une autre méthode pour lui indiquer le nom du réseau et la clé Wifi Connecter le câble RJ45 (Ethernet) fourni à un routeur disposant d'un serveur DHCP (c'est le cas de toutes les box Internet et sur la plupart des réseaux d'entreprise, mais dans ce dernier cas il pourrait y avoir aussi un contrôle d'accès n'autorisant que les ordinateurs connu à se connecter) Connecter directement votre robot à votre ordinateur à l'aide du câble RJ45 fourni (une configuration plutôt pratique, mais qui créé parfois des complications dans le paramétrage réseau selon votre système d'exploitation et vos logiciels installés) Une fois que vous êtes connecté via une de ces méthodes, pour trouver l'adresse de votre robot sur le réseau, nous utilisons le protocole Zeroconf. Il vous permet d'utiliser le nom d'hôte du robot: \"poppy.local\" comme adresse dans votre navigateur. Cela devrait fonctionner sans aucune configuration sous Mac OS et GNU/Linux. Mais il faudra installer lesservices d'impression Bonjour pour Windows. Si vous préférez, vous pouvez utiliser l'adresse IP attribuée à votre robot à la place. Si vous n'êtes pas l'administrateur de votre réseau, cela peut être une information difficile à trouver. Dans ce cas, la première procédure devrait être privilégiée. Pour vérifier que tout est correctement configuré, vous pouvez accéder à l'url suivante en utilisant votre navigateur Web préféré: http://poppy.local/. Vous pouvez remplacer poppy.local par l'adresse IP de votre robot (quelque chose de similaire à http://192.168.0.42). Attention Si vous n'êtes pas familier avec la configuration du réseau ou si vous n'avez aucune idée de ce que le paragraphe précédent a mal essayer d'expliquer, vous devriez voir avec l'ingénieur du réseau informatique, comment cela peut être fait. Utiliser l'interface web L'interface web est le point central pour contrôler, programmer et configurer votre robot. Il peut être utilisé pour: Surveiller et contrôler le robot * Programmer le robot en Snap! Programmer le robot en Python Configurer le robot (changer son nom, activer/désactiver la caméra, faire une mise à jour) Réinitialiser et éteindre le robot Pour accéder à cette interface web, il vous suffit d'accéder à l'URL à l'aide de votre navigateur Web préféré : http://poppy.local (si vous avez changé le nom de votre robot, remplacez simplement poppy par son nouveau nom) ou en utilisant directement l'adresse IP du robot Vous devriez voir quelque chose comme : Les boutons permettent d'accéder aux différentes fonctionnalités. Par exemple, si vous cliquez sur Monitor and Control, vous accédez à l'application web du moniteur : Cela vous permet d’activer / désactiver les moteurs de votre robot, de les surveiller et de commencer / arrêter les comportements. Le bouton What happened c'est où vous devriez regarder pour plus d'informations si quelque chose qui ne va pas. Voici une capture d'écran de ce que vous devriez voir si tout va bien : Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"getting-started/program-the-robot.html":{"url":"getting-started/program-the-robot.html","title":"Programmer un robot","keywords":"","body":"Programmer le robot Les robots Poppy sont pensés pour être programmé facilement. Voici les trois principales façons d'y parvenir : avec la programmation visuelle Snap!, une variante de Scratch, avec Python et la possibilité de s'appuyer sur la puissance de l'API tout entière, * avec REST API, qui permet de connecter les robots Poppy à d'autres outils ou d'utiliser n'importe quel langage de programmation. Important : Tout comme le reste du projet, toute notre bibliothèque logiciel est open source (Licence GPLv3) et disponible sur GitHub. Avec Snap! Snap! est un langage de programmation visuel - une variante du déjà très connu language Scratch. C'est un langage de programmation basé sur l'utilisation de blocs facilement déplaçable, qui permet une bonne introduction à l'informatique. It runs in your browser as it is implemented in JavaScript. Vous n'avez pas besoin d'installer quoi que ce soit pour l'utiliser. Il est open source et mis à jour régulièrement. Nous avons créé plusieurs blocs propre à l'utilisation des robots Poppy qui permettent de contrôler chaque moteur et de lire les valeurs rapportées par les capteurs de votre robot. This let you to directly jump into controlling and programming your robot without any syntax/compilation issue. Snap! permet d'avoir une interactivité constante entre son interface et le robot. Vous n'avez qu'à cliquer sur un bloc et la commande associée se lance. La simplicité apparente de Snap! n'empêche pas de développer des projets de plus en plus complexes. Pour découvrir comment foncitonne Snap et la programmation visuelle par blocs avec Poppy, rdv dans le chapitre dédié. Avec Python Les librairies logicielles Poppy ont été écrites en Python, ce qui permet un développement et une extensibilité rapide, ainsi que de pouvoir utiliser n'importe quelle autre librairie scientifique. Python est d'ailleurs un langage très connu et largement utilisé dans les domaines de l'éducation et artistiques. En programmant Poppy en Python, vous aurez accès à tous les niveaux d'API, du plus bas au plus élevé. L'API a été pensée pour du prototypage très rapide. Créer un robot et faire bouger ses moteurs ne doit pas prendre plus de quelques lignes : from pypot.creatures import PoppyErgoJr jr = PoppyErgoJr() jr.m3.goal_position = 30 Nous aimons énormément le Jupyter Project et de ses notebooks. Les Notebooks sont des documents qui contiennent à la fois du code en Python et des éléments textuels tels que des équations, des photos, des vidéos. Ils peuvent être édités à partir de l'interface Jupyter Web, ce qui permet aux utilisateurs de programmer les robots Poppy directement à partir d'un site hébergé par l'ordinateur du robot. Nous pensons qu’il s’agit d’un outil puissant permettant la création et le partage de code en direct, la visualisation des résultats et des textes explicatifs, le tout combiné en un seul document. La plupart des tutoriels, expérimentations et activités pédagogiques que la communauté Poppy et nous proposons sont disponibles sous forme de notebooks. Info Vous pouvez retrouvez une mise à jour de la galerie de noteboks ici. Toute contibution est la bienvenue ! Avec l'API REST En plus de Snap! et de Python, nous voulions donner la possibilité de recourir à d'autres options pour accéder et contrôler votre robot depuis n'importe quel système ou langage de programmation. Les robots Poppy fournissent une API REST. Les fonctionnalités les plus importantes sont accessibles depuis les requêtes HTTP GET/POST. D'un point vue plus pratique, cela vous permet de : créez des passerelles pour controler le robot Poppy dans n'importe quel langage (des contributeurs géniaux ont déjà écrit des wrappers sur Matlab et Ruby). Créez des des applications web connectées à votre robot, telle qu'une interface moniteur (encore une contribution !). Faites intéragir votre robot avec d'autres objets connectés tels que les smartphones, les capteurs intelligent, ou encore votre compte Twitter... Attention L'API REST est encore une option en cours de développement, des changements y seront apportés, et la documentation n'est absolument pas terminée ! Pour plus d'informations, jetez un oeil ici ou alors sur notre forum. Une API REST bien conçue, stable et bien documentée est prévue pour la prochaine mise à jour majeure du logiciel. Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"getting-started/visualize.html":{"url":"getting-started/visualize.html","title":"Visualiser ou simuler","keywords":"","body":"Utiliser les robots dans un simulateur Robots Poppy simulés Une version simulée de chaque robot Poppy est disponible (Humanoid, Torso, Ergo Jr). On peut utiliser deux « simulateurs » avec les robots Poppy : CoppeliaSim : un simulateur de robotique avec de nombreuses possibilités et très utilisé un visualisateur web-3D : plus léger, mais sans simulation physique Attention Pour le moment seul l'Ergo Jr peut être utilisé dans le visualiseur web. Si vous souhaitez simuler d’autres créatures, vous devez utiliser CoppeliaSim. On souhaiterai prendre en charges les autres robots, mais aucun calendrier n'est fixé sur ce point là. L'utilisation d'un simulateur est très intéressante. Cela permet de développer et d'essayer des programmes sans avoir besoin d'un vrai robot. Plus particulièrement, cela permet : De découvrir et tester les possibilités du robot sans avoir à dépenser d'argent. De travailler dans un contexte où plusieurs utilisateurs partagent un robot. Par exemple, dans une salle de classe, chaque élève peut travailler en utilisant le simulateur et venir valider son programme sur le robot tangible. D'économiser du temps dans la conception et réalisation d'expériences. Nous essayons de faire en sorte que le passage du robot virtuel au tangible soit aussi transparente et simple que possible. La plupart des exemples de programmation et de la de documentation du code sont ainsi valable aussi bien pour les robots simulés que tangibles. Le chapitre de la simulation au robot tangible vous guidera dans les étapes pour adapter votre programme fonctionnant dans le simulateur vers l'usage d'un robot tangible. Attention Si vous souhaitez utiliser des robots Poppy dans un simulateur vous devrez installer le simulateur ainsi que librairies logicielles sur votre ordinateur. Installer les logiciels nécéssaire Pour information : Une section entière est dédiée à comment installer tout en local dans le but d'utiliser un simulateur si vous avez besoin de plus de renseignements. Alors que les robots physiques disposent d'un ordinateur embarqué pré-installé, vous devez installer certaines bibliothèques logicielles sur votre ordinateur pour contrôler les créatures Poppy simulées. Vous n'aurez pas accès à l'interface web du robot. Vous devrez lancer manuellement les différents services pour commencer à programmer votre robot (le terminal Jupyter pour les notebooks Pyhton ou le terminal Snap ! ). Pour commencer à contrôler un robot Poppy, que ce soit en utilisant CoppeliaSim ou le visualiseur web, vous aurez besoin : de Python > = 3.5 de la bilbiothèque Python nommée pypot de la bibliothèque Python correspondant à votre créature (p. ex. poppy-ergo-jr). Avec CoppeliaSim (anciennement V-REP) CoppeliaSim est un simulateur de robotique très populaire aux nombreuses fonctionnalités. Il est très utilisé dans pour la recherche ou des fins éducatives. De plus, il est disponible gratuitement avec la license éducative. Il peut être téléchargé depuis le site de Copellia Robotics (fonctionne sous Mac OS, Windows et GNU/Linux). Attention Etant donné que CoppeliaSim effectue une simulation physique ainsi qu'un rendu graphique du robot, il nécessite un ordinateur puissant (surtout pour la carte graphique). Tous les principaux robots Poppy sont disponibles dans CoppeliaSim : Poppy Humanoid Poppy Torso * Poppy Ergo Jr V-REP permet d’apprendre à commander les moteurs, interroger les capteurs, mais aussi d’interagir avec l’environnement simulé. On peut commander les robots simulés en Python, avec Snap ! ou par le biais de l’API REST. Voici quelques exemples de ce que la communauté a déjà pu faire avec : Une activité pédagogique pour découvrir les différents moteurs de votre robot et comment ils peuvent être contrôlés. Une expérience scientifique, où un Poppy Torso apprend comment pousser un cube sur une table en face de lui. Pour information Même si nous essayons de reproduire le comportement et le fonctionnement du robot, quelques différences persistent. Par exemple, si vous faites marcher un robot dans la simulation, cela ne veut pas dire que le robot physique marchera (et vice-versa). Pour démarrer le robot simulé, il faut dans un premier temps ouvrir CoppeliaSim et instancier le robot avec simulateur = « vrep ». CoppeliaSim va ouvrir une popup qui vous devrez fermer pour permettre la communication entre CoppeliaSim et Python. from pypot.creatures import PoppyErgoJr robot = PoppyErgoJr(simulator='vrep') Si vous souhaitez contrôler un robot simulé via Snap!, vous pouvez également le lancer directement depuis l' interface de ligne de commande poppy-services dans votre terminal (appelée invite de commande sous Windows) : poppy-services --vrep --snap poppy-ergo-jr En utilisant notre visualiseur web Notre visualiseur web permet d'afficher une représentation 3D d’un robot Poppy. Pour ce faire, vous aurez besoin de le connecter soit à un vrai robot (via l’API REST) soit à un robot simulé sur votre ordinateur. Vous devez simplement définir la variable host depuis l’interface web pour pointer sur l’adresse de votre robot. En Python, vous pouvez démarrer le robot simulé avec : from pypot.creatures import PoppyErgoJr robot = PoppyErgoJr(simulator='poppy-simu') Ajouter un argument use_snap = True si vous souhaitez démarrer l'API Snap. Si vous souhaitez contrôler un robot simulé avec Snap!, vous pouvez également le lancer directement avec l'outil interactif poppy-services dans un terminal (appelée ligne de commande sous Windows) : poppy-services --poppy-simu --snap poppy-ergo-jr En ce qui concerne CoppeliaSim, vous pouvez contrôler votre robot en utilisant Python, Snap!, ou l’API REST. Cependant il n’y a pas de support pour la simulation physique; c'est plus léger en terme d'exécution mais vous ne serez pas en mesure d’interagir avec des objets. Voici un exemple avec Python : Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"getting-started/example-of-projects.html":{"url":"getting-started/example-of-projects.html","title":"Exemples de projets","keywords":"","body":"Vue d’ensemble des projets développés par la communauté La communauté Poppy rassemble une communauté interdisciplinaire de débutants, d'experts, de chercheurs, d'enseignants, de développeurs et d'artistes. Des créations robotiques interdisciplinaires et diverses sont apparus. Certaines d'entre elles sont illustrées ci-dessous. School of Moon La pièce School of moon a été créer par la troupe Shonen sous la direction du chorégraphe Eric Minh Cuong Castaing. Elle présente un certain nombre d'artistes : des enfants, deux danseurs (Gaëtan Brun Picard et Ana Pi), trois robots Nao et deux robots Poppy Humanoid. Cette pièce est une métaphore de la création d’une post-humanité en trois actes : l’Homme, l’Homme et la machine et la machine. Les représentations sont locales, c'est à dire que les enfants participant aux différentes résidences de la troupe viennent des villes choisies. Certaines séquences de la pièce dépendent aussi des robots disponibles dans ces mêmes villes. Les défis artistiques sont : Mettre en scène des enfants Créer l'intéraction Homme - machine sur scène * Avoir des robots sur la scène La création s'est effectué sur 4 périodes : 2 semaine de résidence au CDC de Toulouse en septembre 2015 2 semaines de résidence au KLAP de Marseille en décembre 2015 4 semaines de résidence au Ballet National de Marseille en janvier 2016 2 semaines de résidence à Düsseldorf Projet Cherry Le projet Cherry est un projet communautaire qui a pour but d'élaborer des scénarios pour rompre l’isolement des enfants à l’hôpital. Ce projet utilise les robots Poppy comme compagnon pour les enfants d'école primaire hospitalisés. Cherry peut compenser une rupture social dûe à l'hospitalisation. Il sert d'intermédiaire entre l'enfant, ses amis et les enseignants. Il peut lui parler ou jouer à des jeux. Il agit également sur le plan pédagogique, afin d'encourager l'enfant à intéragir avec l'école, en proposant des quizzs et des jeux éducatifs. Cherry permet aussi d'assister le personnel de l'hôpital dans l'éducation thérapeutique. En effet, parfois un message est mieux assimilé par l’enfant si il est délivrée par le robot plutôt qu’un adulte habillé comme un médecin. Pour en savoir plus : La page Facebook Le compte Twitter Le blog WordPress The github (with a short wiki) Connecter Poppy et Arduino grâce à Snap4Arduino Gilles, Enseignant le jour et bricoleur la nuit, a développé de nombreux projets basés sur Poppy Ergo Jr et Arduino. Pour connecter ces deux univers, il utilise Snap4Arduino. Ainsi, il devient facile et élégant de les faire communiquer entre eux. Vous pouvez tout simplement adapter Arduino aux blocs Snap! du robot Poppy et tadam, vous pouvez contrôler votre robot avec n'importe quel capteurs de l'Arduino. Then the only limitation is your creativity! For instance, you can make Poppy Ergo Jr plays TicTacToe: Vous retrouverez la documentation détaillée dans la section Contrôler les robots Poppy avec une Arduino. Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"assembly-guides/":{"url":"assembly-guides/","title":"Guides d'assemblage","keywords":"","body":"Veuillez choisir ci-dessous la créature Poppy que vous souhaitez assembler: Assembler l’Ergo Jr Assembler Poppy Humanoid Assembler Poppy Torso Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"assembly-guides/ergo-jr/":{"url":"assembly-guides/ergo-jr/","title":"Assembler l’Ergo Jr","keywords":"","body":"Guide d’assemblage pour l'Ergo Jr Poppy Ergo Jr est un robot éducatif peu onéreux qui se présente sous la forme d'un petit bras robotique à 6 degrés de liberté. Il se compose de formes très simples qui peuvent être facilement imprimés en 3D. Elles sont assemblées par des rivets qui peuvent être mis ou enlevés très rapidement avec l’outil OLLO. Son embout peut être facilement changé. Vous pouvez choisir parmi plusieurs outils : un abat-jour, une pince, ou un porte-stylo. Grâce aux rivets ils peuvent être rapidement et facilement échangés. Cela permet d’adapter l'outil en fonction en fonction de vos utilisation du robot. Ce chapitre vous guidera à travers toutes les étapes nécessaires pour assembler entièrement un Poppy Ergo Jr. Suivez dans l'ordre : La liste des composants (BOM) la configuration des moteurs l'assemblage électronique l'assemblage des pièces mécaniques L'assemblage en entier devrait prendre 3/4 heures pour votre première construction. Avec un peu de pratique, une demi heure devrait être suffisante. Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"assembly-guides/ergo-jr/bom.html":{"url":"assembly-guides/ergo-jr/bom.html","title":"La liste des composants (BOM)","keywords":"","body":"Poppy Ergo Jr: Liste des composants (BOM) D'abord, ouvrez votre boîte, sortez tous les composants de leur carton ou sachet et préparez un espace de travail propre et espacé. Regardons le contenu de votre kit ! Si vous imprimrez votre propre robot en 3D, cette liste vous aidera également à vérifier que vous disposez de tous les composants requis. Ce qui est inclu ... 1x carte Raspberry Pi board: cette carte est le mini-ordinateur jouant le rôle du cerveau de votre robot 1x carte microSD avec le logiciel Poppy préinstallé : elle s'insère dans la Raspberry Pi 1x caméra pour Raspberry Pi camera, avec sa nappe (càd son câble plat) 1x alimentation 7.5V 2A avec un adaptateur Jack 2.1 x 5.5 x 9.5 (généralement ce modèle) 1x câble Ethernet court pour communiquer avec le robot avant d'activer le Wifi 6x moteurs XL-320: ces moteurs, accompagnés d'un câble noir chacun, s'appellent des servomoteurs : ils sont plus intelligents qu'un moteur basique car ils sont capables de respecter une consigne de position angulaire ou de vitesse de rotation 1x carte Pixl: cette petite carte s'enfile sur le connecteur supérieur de la Raspberry Pi pour lui permettre de communiquer avec les moteurs XL-320 1x sac de rivets Ollo (environ 70 de couleur et 4 gris) 1x outil Ollo: cet outil noir permet d'enfiler et retirer des rivets Ollo Pièces en impression 3D: Soit à imprimer vous-mêmes grâce aux fichiers STL soit vous les avez dans votre kit : 1x base.stl 3x horn2horn.stl 3x side2side.stl 1x long_U.stl 1x short_U.stl 1x support_camera.stl les outils pour votre robot (effecteurs): 1x lamp.stl 1x gripper-fixation.stl 1x gripper-fixed_part.stl 1x gripper-rotative_part.stl 1x pen-holder.stl 1x pen-screw.stl 1x disk_support.stl c'est un disque découpé par une machine laser pour reevoir votre robot (plans ici). Screws: 4x vis M2.5x6mm pour fixer la RAspberry Pi sur la base 4x vis M2x5mm pour fixer la caméra 4x écrous M2 pour fixer la caméra 1x entretoise Male/Femelle M2.5 10mm pour empêcher la carte Pixl de bouger >> Etape suivante: Assemblage électronique Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"assembly-guides/ergo-jr/electronic-assembly.html":{"url":"assembly-guides/ergo-jr/electronic-assembly.html","title":"Assemblage électronique","keywords":"","body":"2. Assemblage électronique Avant de commencer à construire votre robot, nous allongs d'abord brancher l'électronique et le connecter à l'ordinateur. La raison de cette connexion anticipée est que nous aurons besoin du logiciel du robot pendant l'assemblage : celui-ci permet de configurer les moteurs. 2.1. Insérer la carte micro SD dans la Raspberry Pi Si vous avez acheté un kit, le logiciel Poppy est pré-chargé sur votre carte SD. Si ce n'est pas le cas, vous aurez besoin de \"flasher\" votre carte micro SD avec l'image du logiciel Poppy Ergo Jr. La procédure est décrite à cet emplacement. Ensuite, insérez la carte micro SD dans la Raspberry Pi : 2.2. Monter la carte Pixl La carte Pixl a 2 rôles : Alimenter le robot complet via un adaptateur secteur (ou via une batterie bien que aucun support de batterie n'est vendu avec le kit) Communiquer avec les moteurs XL-320 via la Raspberry Pi Insérez minutieusement la carte Pixl au bout des 40 broches dépassant de la Raspberry Pi : Utilisez l'entretoise et la vis fournies dans votre kit de manière à ce que la carte Pixl soit solidement branchée sur la Raspberry Pi : à gauche sur les broches, à droite sur l'entretoise. Si elle est lâche, cela pourrait causer des redémarrage intempesifs de votre robot avec le temps. Avant d'aller plus loin, vérifiez avec insistance que votre carte Pixl : est connectée à la toute fin sur les 10 dernières broches de la Raspberry Pi (vérifiez que vous ne connectez pas seulement 5 broches sur les 10) est dirigée vers l'intérieur de la Raspberry Pi est montée exactement comme sur l'image ci-après 2.3. Avertissements Veuillez lire avec précaution ces recommandations pour éviter de dégrader votre matériel : Caution Déconnectez l'alimentation du robot avant de (dé)monter la carte Pixel sur la Raspberry Pi cette carte n'est pas faite pour être branchée \"à chaud\", il y a un risque de l'endommager si vous le faîtes N'utilisez jamais plusieurs sources d'alimentation en même temps : quand l'alimentation secteur du robot est branchée, n'essayez pas d'alimenter la Raspberry Pi avec d'autres sources de courant tels qu'un câble micro-USB ou des batteries, vous l'endommageriez immédiatement Votre carte Pixl doit être solidement attachée : Au premier usage, vous pourriez penser qu'insérer la carte Pixl sur les 10 broches est suffisant pour la maintenir mécaniquement ; cependant à la longue, du jeu dans cette connexion pourrait apparaître et causer le redméarrage intempestif du robot pendant sa manipulation : assurez-vous d'utiliser une entretoise et une vis pour fixer la Pixl 2.4. Premier démarrage ! Ensuite, branchez un câble moteur noir (fourni dans les sachets de moteur) sur la Pixl et laissez l'autre côté du câble déconnecté. Enfin connectez l'adaptateur secteur sur une prise de courant. Faîtes ensuite attention à ces 2 LED de la Raspberry Pi : la LED rouge (PWR = power = alimentation) doit rester allumée de manière fixe ; ce qui signifie que la carte est correctement alimentée. Si ce n'est pas le cas, vérifiez toutes les connexions, particulièrement que la carte Pixl est correctement montée la LED verte (ACT = activité) doit vaciller pendant environ 45 secondes, ce qui signifie que la carte est en train de démarrer. Si ce n'est pas le cas, vérifiez que la carte SD est bien munie d'une image valide du logiciel, ou bien essayez de la re-flasher Si vous avez vu la LED verte vaciller pendant environ 45 secondes en branchant le robot, continuez à l'étape suivante pour configurer les moteurs ... >> Etape suivante : configurer mes moteurs Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"assembly-guides/ergo-jr/motor-configuration.html":{"url":"assembly-guides/ergo-jr/motor-configuration.html","title":"Configuration des moteurs","keywords":"","body":"3. Configuration des moteurs L'Ergo Jr est composé de 6 moteurs XL-320 motors du constructeur Robotis. Chacun de ces servomoteurs embarque un circuit électronique lui permettant de recevoir différents types de commandes (en position angulaire, en vitesse, ou en force) et de communiquer avec les autres servomoteurs. Ainsi, vous pouvez chaîner plusieurs servomoteurs et tous les commander depuis un seul câble branché au début de la chaîne : chaque servomoteur transmettra les commandes au moteur suivant et ainsi de suite. Cependant, avant de pouvoir chainer ces moteurs les uns aux autres, il va falloir d'abord leur attribuer un identifiant unique (càd un nom unique). En sortie d'usine, tous les moteurs ont le même identifiant, ce qu'il faudra donc corriger dans cette section. Nous vous recommandons de configurer les moteurs en parallèle de l'assemblage mécanique de l'étape suivante. Ce qui signifie que vous ne devriez pas configurer tous les moteurs dans l'étape actuelle : il est seulement nécessaire de lire cette page attentivement et de faire quelques essais de configuration de moteur pour vous faire la main, mais vous configurerez tous les moteurs durant l'étape prochaine. Sachez qu'un moteur peut être reconfiguré autant de fois que vous le souhaitez. 3.1. Préparer le matériel Si vous utilisez Windows (ce n'est pas nécessaire sur GNU/Linux ou Mac OSX), vous devez d'abord installer Bonjour/Zeroconf (Lien de téléchargement pour Windows) ou bien avahi pour pouvoir vous connecter au robot. Consultez la page Bonjour/Zeroconf pour plus de détails. Mettez en marche le robot, avec ou sans moteur connecté : connectez le câble Ethernet (RJ45) entre le robot et vous box Internet ou routeur connectez l'alimentation secteur Note : Bien qu'il est possible de connecter le câble Ethernet directement entre le robot et votre ordinateur sans utiliser de box/routeur. Mais cette méthode nécessite des étapes de configuration réseau supplémentaire avec Zeroconf donc nous ne la recommandons pas au premier abord. Votre robot démarre ... vérifiez que la LED vert ACT de la Raspberry Pi vacille environ 45 secondes. Si ce n'est pas le cas, vérifiez que la carte SD est bien munie d'une image valide du logiciel, ou bien essayez de la re-flasher. 3.2. Configurer les moteurs un-par-un (cas nominal d'un robot acquis après Octobre 2020) Depuis votre ordinateur, ouvrez maintenant un navigateur Web (Mozilla Firefox, Chrome, Edge, ...) et chargez l'URL suivante dans la barre d'adresse : http://poppy.local. La page d'accueil du robot doit apparaître. Si ce n'est pas le cas et qu'une erreur de votre navigateur comme ci-dessous apparaît, vérifiez que vous n'avez pas omis le préfixe http://, et vérifiez que Bonjour est correctement installé sous Windows. Sur GNU/Linux, il peut être nécessaire de paramétrer le réseau Ethernet en mode \"Réseau local seulement\". Si le problème persiste, il s'agît d'un problème réseau, testez avec ou sans routeur entre le robot et l'ordinateur, ou avec un autre routeur. La configuration d'un moteur est une configuration individuelle pour chaque moteur. Cela signifie que durant la configuration d'un moteur, seulement le moteur en cours de configuration doit être branché à la Pixl. Configurer un moteur revient à lui attribuer un nom m1, m2, m3, m4, m5 ou bien m6 en suivant la convention de nommage suivante : En vue de configurer un moteur, vous aurez à connecter seulement les éléments suivants : La Raspberry Pi La carte Pixl L'alimentation secteur 1 seul câble de moteur allant de la carte Pixl jusqu'à l'unique moteur en cours de configuration le câble Ethernet connectant votre Raspberry Pi au réseau Au premier démarrage, un assistant vous guide dans la configuration initiale du robot. Suivez les étapes jusqu'à atteindre Etape 2 : configuration des moteurs : Note : Si vous robot affiche une toute autre page mais pas l'assistant, il se peut que vous ayant un ancien logiciel chargé sur votre robot. Dans ce cas consultez la section 3.2.bis. ci-dessous pour configurer vos moteurs. Configurons un moteur maintenant : connectez un seul moteur à la carte Pixl, choisissez un nom de moteur dans la liste (par exemple m5) et cliquez sur le bouton Configurer. Vous verrez un descriptif de ce qu'il se passe s'afficher dessous le bouton. Si aucune erreur ne survient, la dernière ligne doit être Done!. Sinon, le détail de l'erreur anglophone peut vous aider à lcoaliser le problème. Chaque fois qu'un moteur est correctement configuré, son palonnier (la roue noire) est placée en position zéro, donc si vous voyer tourner c'est généralement bon signe ; mais s'il ne bouge pas ne vous inquiétez pas, il était peut-être déjà en position zéro. Vous aurez besoin de débrancher le moteur pour pouvoir le bouger à la main et le rebrancher si vous souhaitez le voir bouger en position zéro. Rappelez-vous que vous ne devriez pas configurer tous les moteurs maintenant. Si vous l'avez déjà fait n'ayant pas d'inquiétude, les moteurs peuvent être reconfigurés un nombre de fois illimité si vous avez besoin de recommencer pendant l'étape de construction mécanique qui suit ... >> Etape suivante : construction mécanique 3.2.bis. Configurer les moteurs un-par-un (si vous avez une ancienne version de logiciel) Avant Octobre 2020 l'Ergo Jr n'avait pas d'assistant au premier démarrage, dans ce cas vous voyez directement s'afficher la page d'accueil. Dans ce cas, la configuration des moteurs se déroule avec l'outil nommé Poppy Configure. Suivez ces étapes : Ouvrir un terminal Premièrement ouvrez la page d'accueil sur http://poppy.local, sélectionnez terminal Python ou bien Programmation Python et ouvrez ensuite Nouveau terminal comme montré ci-dessous : Le terminal est l'encart noire qui s'affiche à lécran, dans lequel vous povuez taper des commandes et visualiser leur résultat : Configurer un motor Pour configurer un moteur avec Poppy Configure, tapez la commande poppy-configure ergo-jr dans laquelle vous remplacez par un nom de moteur entre m1 et m6. Vérifiez qu'aucune erreur n'appraît lorsque la commande se termine et que la dernière ligne est Done!. >> Etape suivante : construction mécanique 3.2.ter. Configurer les moteurs un-par-un (si vous utilisez une image ROS) Si vous ne savez pas ce qu'est ROS, cette procédure n'est probablement pas pour vous. L'image ROS pour Poppy Ergo Jr est dépourvue d'interface graphique. Pour se connecter au logiciel et configurer les moteurs nous allons utiliser SSH depuis un terminal de votre station de travail. Ouvrir un terminal via SSH Depuis votre station de travail Linux ou MacOS, ouvrez un terminal puis tapez la commande ssh poppy@poppy.local : Il vous sera d'abord demandé de confirmer la connexion en tapant yes Puis vous devrez taper le mot de passe poppy Votre invite de commande doit désormais afficher poppy@poppy au lieu de votre invite habituel, ce qui confirme que vous êtes connecté au robot via SSH Note : Si l'erreur ssh: Could not resolve hostname poppy.local: Name or service not known apparait, vous avez un défaut de connexion réseau Configurer un motor Pour configurer un moteur avec Poppy Configure, branchez un unique moteur à la carte Pixl puis tapez dans le terminal SSH la commande poppy-configure ergo-jr en remplaçant le nom du moteur par le bon nom entre m1 et m6. Vérifiez qu'aucune erreur n'apparaît lorsque la commande se termine et que la dernière ligne est Done!. Vous pouvez ensuite passer au moteur suivant. >> Etape suivante : construction mécanique Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"assembly-guides/ergo-jr/mechanical-construction.html":{"url":"assembly-guides/ergo-jr/mechanical-construction.html","title":"Assemblage des pièces mécaniques","keywords":"","body":"4. Assemblage mécanique 4.1. Avis et avertissements d'ordre général Toutes les orientations des pièces sont très importantes. Regarez les photos très précisément pour reproduire le même assemblage avec les pièces dans le même sens. Si vous vous trompez, vous vous en rendrez compte car votre robot réalisera des mouvements différents que ceux que vous lui demanderez. Le cas échéant n'ayez pas d'inquiétude, vous pourrez toujours le démonter puis le remonter. Vous pouvez pré-assembler tous les rivets dont vous avez besoin avant la construction du robot. Chaque rivet consiste en l'assemblage de deux éléments l'un dans l'autre comme ceci : Il y a 2 sortes de rivetsThere are two kinds of rivets. The grey ones and the others. Grey rivets are longer to be able to be inserted in the motor axis, at the opposite side of the horn (black revolving circle). Utilisez l'outil OLLO pour pouvoir monter et démonter les rivets facilement. N'oubliez pas de passer les fils pendant l'assemblage de votre robot. Chaque moteur, excepté le dernier doit avoir ses 2 connecteurs occupés: l'un connecté au moteur précédent, l'autre connecté au moteur suivant. Il n'y a cependant pas d'importance quant-à quel connecteur est connecté au moteur suivant ou précédent. vérifiez que le palonnier (la roue noire) du moteur est toujours dirigée vers le haut du moteur avant de l'assembler, c'est à dire qu'il est en position zéro comme après une configuration. Sinon votre Poppy Ergo Jr aura l'air tout à fait bizarre. Tous les palonniers des moteurs (la roue noire) doivent être alignés sur le côté gauche du robot : 4.2. Guide pas à pas Configuration des moteurs Les moteurs doivent être individuellement configurés. Vous pouvez faire cela avant ou après la construction de votre robot mais dans la mesure ou cela nécessite d'avoir un seul moteur branché à la carte Pixl à la fois, il est généralement plus pratique de configurer les moteurs un-par-un, se souvenir du nom qu'il leur a été attribué, et assembler ce moteur au bon endroit dans le robot ensuite. Attention Pour configurer les moteurs, vous devez les connecter séparément un par un à la Raspberry Pi. Si vous essayez de configurer un nouveau moteur alors qu'il est connecté avec le moteur précédent, cela ne fonctionnera pas. Pour plus d’informations, consultez la section précédente configuration de moteur. Etape 1 - moteur 1 Tout d’abord, démarrez votre robot et configurez un moteur XL-320 sous le nom « m1 ». Montez ensuite le moteur sur la base imprimée en 3D. Pour cela, préparez 8 petits rivets. Placez la première partie dans la seconde sans les mettre à l'intérieur du moteur. Ensuite, placez le moteur sur la base avec le palonnier (= la roue du moteur) faisant face au côté le plus ouvert. Utilisez l'outil Ollo pour attraper le rivet entre la première et la seconde partie du rivet puis insérez le rivet dans un des trous d'assemblage. Une fois le rivet en place, verrouillez-le en poussant la première partie du rivet vers la seconde. Étape 2 - moteur 2 Configurez le second moteur, son nom est « m2 ». Monter la partie long_U. Soyez prudent avec l’orientation de la la pièce, le palonnier doit être orienté vers la gauche. Monter le moteur « m2 » sur le dessus de la construction. Étape 3 - moteur 3 Configurer un troisième moteur nommé « m3 ». Monter les pièces horn2horn et horn2side sur moteur « m2 » et monter « m3 » sur le dessus de la construction. Étape 4 - moteur 4 Configurer le quatrième moteur nommé « m4 ». Monter la pièce short_U sur le moteur 4. Monter le moteur « m4 » et la pièce short_U préalablement assemblée au sommet de la construction. Le nez du moteur doit être orienté vers l'arrière de la base. Étape 5 - moteur 5 Configurer le cinquième moteur nommé « m5 ». Monter les pièces horn2horn et horn2side sur moteur « m4 » et monter « m5 » sur le dessus de la construction. Étape 6 - l’outil de votre choix Configurer le sixième moteur nommé « m6 ». Pour terminer votre Ergo Jr, vous devez ajouter l'outil de votre choix (effecteur) à son extrémité : un abat-jour, un porte stylo ou une pince. Suivez les instructions appropriées à l'outil choisi. Note Les outils peuvent être facilement et rapidement changés, ce qui vous permet d'adapter votre robot aux différentes activités. Étape 6 Option 1 : L'abat-jour ou le stylo Monter les pièces horn2horn et horn2side sur moteur « m5 » et monter « m6 » sur le sommet de la construction. Vous pouvez monter le support de stylo ou de l’abat jour sur le moteur « m6 ». L'abat jour et le porte-stylo s'installent de la même manière. Étape 6 Option 2 : La pince Montez la pièce gripper-fixation entre les moteurs \"m5\" et \"m6\". Monter la pièce gripper-fixed_part et gripper-rotative_part sur le moteur \"m6\". Il y a deux façons de monter la pince, verticalement ou horizontalement Étape 7 - électronique Monter la pièce support_camera sur la base. Fixez la caméra de Raspberry Pi sur le support et camera on it and move the camera flex cable between motor \"m1\" and the base. Nappe de caméra Pour connecter la caméra : ouvrez le connecteur de nappe en tirant le levier en plastique autour du connecteur vérifiez que la partie métallique du connecteur tournent le dos au porte Ethernet de la Raspberry Pi (RJ45) insérez la nappe dans le connecteur refermez le loquet en plastique Cales moteurs : Vous povuez maintenant chainer tous les moteurs les uns aux autres. Chaque moteur a au final ses deux connecteurs de branchés, le premier au moteur précédent et le deuxième au moteur suivant. Sauf le tout premier moteur, qui est connecté à la Pixl, et le dernier moteur qui n'a donc pas de moteur suivant. Info Les connecteurs du moteur « m1 » (à la base) sont un peu difficiles à brancher, vous pouvez utiliser l’outil OLLO pour vous aider. Étape 8 - fixer votre Ergo Jr sur le disque de support en bois Montez votre Ergo Jr sur le disque en bois disk-support. Montez la Raspberry Pi sur le disque, et utilisez des vis 4 x M2.5x6mm pour la fixer. Step 9 - Test final de votre robot ! Félicitations, vous avez réussi l'assemblage, il est temps de tester ! Terminez de suivre l'assistant de premier démarrage sur http://poppy.local : Cliquez sur Démarrer l'API Cliquez sur Démarrer une danse Votre robot doit désormais bouger, sans rentrer en collision avec le sol ni avec lui-même. S'il créé des collisions, vérifiez que toutes les pièces et les positions zéros des moteurs sont précisément comme sur les photos. Terminez de parcourir l'assistant de premier démarrage et découvrez tranquillement votre robot. 4.3. Programmer Pour programmer votre robot consultez la section dédiée Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"assembly-guides/poppy-torso/":{"url":"assembly-guides/poppy-torso/","title":"Assembler Poppy Torso","keywords":"","body":"Guide d’assemblage de Poppy Torso Mise en garde Le guide d'assemblage de Poppy Torso n'est disponible qu'en anglais à cet emplacement. Si vous souhaitez aider à la traduction, consultez ce document. Bon assemblage ! Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"assembly-guides/poppy-torso/warnings.html":{"url":"assembly-guides/poppy-torso/warnings.html","title":"PRIMORDIAL warnings","keywords":"","body":"Primordial warnings to assemble a Torso Ignoring these warnings will necessarily lead to a non-working robot and broken hardware It is primordial that your read and understand these warnings below before doing anything with your hardware. PRIMORDIAL warning #1 : Align the horn with the motor axis When a Dynamixel motor is sold, its horn (the metallic wheel) is shipped separately from the motor iself. It is your role to assemble it on the axis. The active horn has to be assembled by respecting precisely the alignment thanks to the marking as in the pictures below. With MX-28 and MX-28AT motors, the horn is assembled by forcing on it. Hence, if you make a mistake, you will not be able to come back. Be sure of the alignement before forcing with the central screw. PRIMORDIAL warning #2: Don't use too much thread locker Thread locker is included in your kit. Place some thread locker at the tip of all screws to prevent vibrations from untying the screws. However, dipping the extremity of the screw on the thread locker is enough (a drop for each screw hole is too much). Otherwise disassembling your robot can be very hard or impossible! If you're unsure, don't use the thread locker in a first step, it will always be possible to put it later when you know your robot better. PRIMORIDAL warning #3: Align the horn with 3D-printed parts Notice that horns all have 3 dots and that the 3D-printed parts also have them close to motor axes. Generally, the opposite axis of the motor axis is a free wheel and 3D-printed parts do not have any point in that side ; except for symmetrical parts such as the legs, that have 3 points on both sides. According to the 3D printing technique, the 3 dots might not been easily visible. Some parts, such as the feet, only have 1 visible point because the parts are hollowed the other side. You must align the horn with the 3D-printed parts by matching the 3 points as the picture below. Warning #4: All parts have an unique orientation It is very easy to get trapped by inserting a motor or a part the wrong way. If you do not pay attention you might find that your assembly is correct because holes align well with pieces but they might be incorrect. Don't worry, except for the first and second primordial warnings, your robot can always be disassembled. In order to minimize the risk of mistakes, compare scrupulously your sub-assembly with pictures and videos at each assembly step. These prominent visual elements should help: The position of motor axis (active wheel) vs the position of the free wheel The position of the motor's sticker The position of the motor's electrical connector The curvature of 3D-printed parts Warning #5: Your robot is sensitive to interferences If you meet sporadic communication issues with motors such as DxlError or timeout, it is possible that interferences perturbate your robot. Here are fixes to attempt: Change the motor cables: Motor cables heat and their conductive properties are getting worse over time. A typical example is when you feel that the cable is more rigid than a brand new cable It may be useful to cut the central wire of the cable directly connected to the USB2AX (and only that one). Indeed, it is known that it can create interferences and this wire (+12V) is unused at this location. Next >> 2. Bill Of Material (BOM) Questions ? We're always happy to help with code or other questions you might have! You can ask questions and share solutions on our community Forum. "},"assembly-guides/poppy-torso/bom.html":{"url":"assembly-guides/poppy-torso/bom.html","title":"Bill Of Material (BOM)","keywords":"","body":"2. Poppy Torso Bill of Material Checkout the list of components you need and have a look at your own kit to check that nothing is missing. Prepare a clear workbench that you may keep busy for a few days with all of these. 1. Multiarticulated torso BOM 3D Printed parts: Chest Spine Abdomen Double rotation MX64 Set (3 parts) Double rotation MX28 Set (3 parts) Actuators: 1x Robotis Dynamixel AX12-A (or AX18-A) 5x Robotis Dynamixel MX28-AT (or MX28-T) 2x Robotis Dynamixel MX64-AT (or MX64-T) Robotis parts: 5x HN07-N101 3x HN07-I101 2x HN05-N102 2x HN05-I102 1x Bioloid 3P PCB HUB 2x SMPS2Dynamixel Motor configuration: 1x 12V power supply 1x USB2AX 2. Head BOM (Raspberry Pi 3 version) 3D Printed parts: 1x Head face 1x Head back 1x Fake manga screen (flat fake screen if no actual screen is mounted) 1x Screen support 1x Camera support 1x Speaker left support 1x Speaker right support 1x Neck Actuators: 1x AX-12 or AX-18 Electronics: 2x Speaker 1x Audio amp 1x Raspberry Pi 3 + its SD card 3. Tools Please note that you will also need: an external computer running Linux Windows or MacOS screwdrivers (crosshead and Torx) tweezer hot glue 4. STL files for poppy Torso 3D printing If you are in the process of 3D-printing the parts from this BOM by yourselves, download the latest STL files from: Poppy minimal head design STLs Poppy torso STLs In order to clone these repositories, please use git lfs to retrieve assets such as 3D parts and images. By cloning the repositories with git only, the assets would appear to be corrupted/invalid files. Next >> 3. Dynamixel hardware Questions ? We're always happy to help with code or other questions you might have! You can ask questions and share solutions on our community Forum. "},"assembly-guides/poppy-torso/dynamixel_hardware.html":{"url":"assembly-guides/poppy-torso/dynamixel_hardware.html","title":"Dynamixel hardware","keywords":"","body":"3. Mounting Dynamixel horns The Poppy Torso robot is mainly built with MX-28AT Dynamixel servomotors (MX-28T are the previous version and can be used without any problem). The other servomotors are two AX-12A (or AX-18) which are smaller, used only for the head. Each Dynamixel servomotor embeds an electronic board allowing it to receive different kind of orders (about goal, torque...) and communicate with other Dynamixel servos. Therefore, you can chain up several Dynamixel servomotors (each with a different ID) and command them all from one end of the chain: each servomotor will pass the orders to the next one. Parts used along with Dynamixel motors Here is a table of the parts needed to mount the horns of the motors. Servomotor main horn free horn big horn screw horn screws case screws AX12-A none none M3x10mm M2 M2 MX28 HN07-N101 HN07-I101 M2.5x8mm M2x3mm M2.5x6mm You will need an allen wrench of size 1.5mm for M2 screws, 2mm for M2.5 screws and 2.5mm for M3 screws. The longer M2 screws need a Phillips screwdriver. Mounting and aligning the active horns Don't mount the horns now, you should do it all along the assembly when a motor is needed. This is only general information, not all motors need to be mounted the same way: with or without rear wheel, with or without nuts ; this will be indicated in the videos for each specific motor. When you receive your Dynamixel servomotors, the horns and their washers are not mounted. The latter are included in the same packaging if the servo is packaged alone or they are packaged separately for 6-pieces bulks. On top of the active motor axis (the axis that is driven by the motor), you will mount the horn and the washer (the white washer for the MX-28). As you already read in the PRIMORDIAL warnings #1 and #3 be very careful about the horn alignement both with the active motor axis and the structural part (3D printed). Here are other views of what you need to achieve: Then you can force on the horn to insert it and use a screw (the longest model) with very few thread locker to fix it. But, again, this is definitive. If you are unsure that you have well aligned the active horn If you are unsure that you have well aligned the horn: Install Poppy software and invoke Poppy Configure with the name of a motor of the same model (MX28/MX-28AT) so that it goes to its zero angle. If, after setting your motor to zero angle, the horn does not point upwards as in the image below, then you made a mistake in horn alignment. If you made a mistake in the active horn alignment If you assembled the horn and forced without aligning it correctly, you have two solutions: The offset can be compensated from software in the configuration file of your creature, but this is an advanced operation and you first need to know how much the offset is You can attempt to remove the horn. You will necessarily damage the motor, so be very cautious in order to minimize damages. Proceed as follows: Use a flat screwdriver with a tip of about 2mm in length Remove the center screw if any and carefully slip the tip under the horn Apply a slight rotative pressure pressure on you screwdriver Rotate the horn of 45° and apply another pressure there as shown on the picture Pursue pressures evert 45° all around the horn by keeping your screwdriver always inserted at the same location in order to minimize damages of the black chassis and the washer When the horn is disengaged of about 2mm from the motor (you screwdriver is too narrow to force again), you should be able to pull the horn by hand by pulling very straight and shaking slightly Re-insert then the active horn properly Particular cases of horn alignment according to motor types Horns of motors AX-12 and AX-18 are also oriented but motors are shipped with the horn pre-assembled so there is no danger. Thus, the assembly of motors MX-32 and MX-32AT are the most at risk. Mounting the rear horn (free wheel) In most cases, on the other side of the active/driven horn with the 3 dots, you will have to mount another horn with ball bearings. There is no important alignement on this side, this is just a free wheel. Insert a long screw with very few thread locker. However check that this horn rotate very easily by hand, just as a free wheel would rotate when mounted on a ball bearing. A locked free wheel would prevent the motor from moving. Inserting the nuts Some nuts will have to be inserted in the motors in order to receive the screws allowing the 3D printed parts to be fastened. The location needing nuts will be told in the videos for each motor. In order to place a single nut: Take a nut using thin tweezers and bring it in the sitewith the right orientation. Put the end of the tweezers in the hole to ensure good alignment. Then use flat pincers to adjust the nut. These nuts correspond to diameter 2.5mm screws, Allen wrench 2mm. Older motor version MX-28 have no thread at all, but newer version MX-28AT are partially threaded in a side. So less nuts will be needed with newest motors. Later on, when you tighen the screw, make attention not to push the nuts unintentionally. Once motors are inserted in some structural parts, som nut locations can no longer be reached by hands so you will not be along to insert the fallen nuts again. Next >> 4. Configuring the Dynamixel motors Questions ? We're always happy to help with code or other questions you might have! You can ask questions and share solutions on our community Forum. "},"assembly-guides/poppy-torso/addressing_dynamixel.html":{"url":"assembly-guides/poppy-torso/addressing_dynamixel.html","title":"Configuring the Dynamixel motors","keywords":"","body":"4. Configuring the Dynamixel motors Every Dynamixel motor has its own configuration including: its digital identifier (e.g. id=21, this is the right hip motor) its baudrate: the speed of communication its return delay time: By default all brand new motors have an id = 1 with default communication parameters, so all motors need to be configured one-by-one in order to be attributed their right parameters. Naming convention To simplify the configuration, all Poppy motors are named (e.g. right_shoulder_x) as shown on the naming convention below. It means that given a motor name, software can deduce the right configuration parameters. Connect a single motor to configure it Configuring a single motor requires 1x SMPS2Dynamixel (SMPS) adapter, 1x USB2AX adapter, 1x 12V power supply, and 2x Dynamixel cables. The USB2AX USB adapter allows some computer (the Raspberry Pi or another computer) to communicate with the motors. The SMPS adapter injects power from the wall socket to the data bus, because such powerful motors cannot be powered from USB only. They must be connected this way: Then plug the USB to your computer and the 12V power adapter to the wall socket. Note Removing the central wire of the cable connected to the USB2AX (and only this one) is optional. It is something advised to do it in case of interferences on the data bus Install the driver for the USB2AX adapter On Linux/MacOS On Linux/MacOS, no installation is needed, but you must add yourself in the group which own the USB serial ports. It is \"dialout\" or \"uucp\" depending on your distribution: sudo addgroup $USER dialout sudo addgroup $USER uucp Then you need to logout from your session and login again. On Windows Instructions for Windows ar available here. Use a software to configure the connected motor There are 3 different software tools to configure your motors one-by-one: Poppy Configure: Command-line tool that only requires to provide the motor name Herborist: Graphical tool used in the videos in place of Poppy Configure Dynamixel Wizard: windows-only tool provided by Robotis. You can use whichever one as long as you manage to configure your motor, but we advise Poppy Configure: Poppy Configure Poppy Configure is a command-line tool to configure Poppy motors that is handy because it only requires the name of the motor to configure it. It is pre-installed on the Raspberry Pi image, so you can plug a HDMI monitor and use it in a terminal, but you may also use another computer, as long as you first install Poppy software. Open a terminal and type the command poppy-configure humanoid in which you replace the motor name by the corresponding one. Poppy Configure will configure the motor with the right configuration and then move to zero (angle = 0 degree). We strongly advise you to make advantage of that to double-check that the horn is properly aligned with the motor axis: at 0 degree, the single dot must point upwards. NoteIf Poppy Configure displays such error message: poppy-configure: error: argument robot: invalid choice: 'humanoid', then you have missed the installation of the humanoid creature. Use command pip install poppy-humanoid to fix it. Herborist Herborist can be installed with pip once you have setup a Python environment in your computer: pip install herborist Then, type this command to launch it: herborist Connect each motor one by one to the USB2AX and use the ’scan’ button in Herborist or Dynamixel Wizard to detect it. If it’s a new motor, it should have ID 1 and baudrate 57600bps, apart from AX-12A servos which already have a 1000000 baudrate. You have to set: The digital ID corresponding to the naming convention Baudrate to 1 000 000 bps Return delay time to 0 ms instead of 0.5 ms In Herborist, don’t forget to click on the ’Update EEPROM’ button so the changes are taken in account. When should I configure a motor? Don't make the configuration of all motors now, it is advised to configure a motor each time you mount it into the mechanical structure. NoteYou can setup the configuration of a motor as many times as needed. So there is no danger at making confugration attempts now to check that everything is alright Next : 5. Arms assembly >> Questions ? We're always happy to help with code or other questions you might have! You can ask questions and share solutions on our community Forum. "},"assembly-guides/poppy-torso/arms_assembly.html":{"url":"assembly-guides/poppy-torso/arms_assembly.html","title":"Arms assembly","keywords":"","body":"5. Poppy Torso: Arms assembly Right arm Bill of Material for the right arm 1x Upper arm + Right hand Right Forearm 1x Arm connector Cables: 1x 3P 200mm 1x 3P 140mm Robotis parts: 4 nuts M2 4 Bolts S1 3x HN07-N101 2x HN07-I101 22x Bolts M2x3 26x Bolts M2.5x6 13x Nuts M2.5 Right arm videos Forearm assembly Upper arm assembly Arm/shoulder assembly Final right arm assembly Motor configuration for the right arm Prepare and configure these motors, all with active horns (HN07-N101), and also the free horn (HN07-I101) when indicated. Sub-assembly name Motor name Type ID Free horn Right upper arm/shoulder r_shoulder_x MX-28AT 52 Yes Right upper arm r_arm_z MX-28AT 53 No Right upper arm r_elbow_y MX-28AT 54 Yes Assembly of the right arm Take the right hand and the right forearm. Insert 4 nuts in the hand, then link the 2 parts with the 4 Bolts S1. Insert 5 nuts M2.5 on motor r_elbow_y on the bottom, 4 on the other side. Plug a 140mm cable to r_elbow_y, drag it in the upper-arm and fix it with 18 bolts M2.5. Drag the motor r_arm_z on the top of the upper arm and fix it. Then connect the motors. Fix the arm connector at the top, and the forearm at the bottom with 22 bolts M2. Put 4 nuts M2.5 behind on the bottom of r_shoulder_x. Fix r_shoulder_x on the arm connector with 8 Bolts M2.5 and thanks to the 200mm cable, connect both motors. Left arm Bill of Material for the left arm 1x Upper arm Left hand + Left Forearm 1x arm connector Cables: 1x 3P 200mm 1x 3P 140mm Robotis parts : 4 nuts M2 4 Bolts S1 3x HN07-N101 2x HN07-I101 22x Bolts M2x3 26x Bolts M2.5x6 13x Nuts M2.5 Left arm videos Forearm assembly Upper arm assembly Arm/shoulder assembly Final left arm assembly Motor configuration for the left arm Prepare and configure these motors, all with active horns (HN07-N101), and also the free horn (HN07-I101) when indicated. Sub-assembly name Motor name Type ID Free horn Left upper arm/shoulder l_shoulder_x MX-28AT 42 Yes Left upper arm l_arm_z MX-28AT 43 No Left upper arm l_elbow_y MX-28AT 44 Yes Assembly of the left arm Insert 5 nuts M2.5 on motor r_elbow_y on the bottom, 4 on the other side. Plug a 140mm cable to l_elbow_y, drag it in the upper-arm and fix it with 18 bolts M2.5. Drag the motor l_arm_z on the top of the upper arm and fix it. Then connect the motors. Fix the arm connector at the top, and the forearm at the bottom with 22 bolts M2. Put 4 nuts M2.5 behind on the bottom of l_shoulder_x. Fix l_shoulder_x on the arm connector with 8 Bolts M2.5 and thanks to the 200mm cable, connect both motors. Next >> 6. Trunk assembly >> Questions ? We're always happy to help with code or other questions you might have! You can ask questions and share solutions on our community Forum. "},"assembly-guides/poppy-torso/trunk_assembly.html":{"url":"assembly-guides/poppy-torso/trunk_assembly.html","title":"Trunk assembly","keywords":"","body":"6. Poppy Torso: Trunk assembly 6.1. Chest Bill of Material for the Chest 3D printed parts: Chest Actuators: 1x Robotis Dynamixel AX12-A 2x Robotis Dynamixel MX28-AT Cables: 1x 3P 100mm 2x 3P 140mm Robotis parts : 10x Nuts M2 10x Bolts M2 16x Bolts M2.5 2x HN07-N101 1x Bioloid 3P PCB HUB Chest videos Chest assembly Chest assembly instructions Prepare and configure these motors, all with active horns (HN07-N101 for MX-28AT), without free horns. Sub-assembly name Motor name Type ID Free horn Chest head_z AX-12A 36 No Chest l_shoulder_y MX-28AT 41 No Chest r_shoulder_y MX-28AT 51 No Insert the 10 M2 nuts all around the bottom part of the AX12-A. Lay the AX12-A on the top of the chest, then screw it with the 10 Bolts M2 and plug the 100m cable on the AX12-A, and fix it by passing it in the gap. Plug a 140mm cables between r_shoulder_y and l_shoulder_y. Insert them in their slots in the chest and fix them both with 8 Bolts M2.5. Pass both the 140mm cable in the gap on each side of the chest. Plug the 3 cables on the 3P Extension PCB, with hot glue, fix it behind the chest on top of the Poppy logo. 6.2. Double Dynamixel MX-28 sub-assembly Bill of Material for the Double MX-28 sub-assembly 3D printed parts: 1x i101-Set_to_MX28_link 2x double_rotation_MX28_link Actuators: 2x Robotis Dynamixel MX28-AT Cables: 1x 3P 60mm Robotis parts : 8x Nuts M2.5 8x Bolts M2.5 2x HN07-N101 2x HN07-I101 Double MX-28 sub-assembly videos Double MX-28 assembly Double MX-28 sub-assembly instructions Prepare and configure these 2 motors, both with active horns (HN07-N101). Only one requires its free horn (HN07-I101) but an additional free horn is needed during the sub-assembly. The additional free horn will be mounted to its motor later on. Sub-assembly name Motor name Type ID Free horn Double MX28 bust_y MX-28AT 34 Yes Double MX28 bust_x MX-28AT 35 No Insert a 2.5 nut on the back of the i101-Set_to_MX28_link, and install the second free horn HN07-I101 on it with a central screw. On both double_rotation_MX28_link parts, insert 2 M2.5 nuts. Install them on the bust_x motor. Connect both motors together with the short 60mm cable. Insert 2 M2.5 nuts on bust_y on the same side of the cable. Approach both motors so that their axes form a 90° angle, and fix them by the means of the double_rotation_MX28_link and 4 M2.5 bolts. 6.3. Spine sub-assembly Bill of Material for the Spine 3D printed parts: Spine Tabletop support Actuators : 1x Robotis Dynamixel MX28-AT Cables : 2x 3P 200mm Robotis parts : 4x Nuts M2.5 8x Bolts M2.5 1x HN07-N101 40x Bolts M2x3 4x Bolts M2.5x4 Spine sub-assembly instructions Prepare and configure this motor with its active horn: Sub-assembly name Motor name Type ID Free horn Spine abs_z MX-28AT 33 No Insert 4 nuts in the top face of abs_z. Plug it to a 200mm cable and slide the motor into its slot in the spine. Fix it with the 8 M2.5 Bolts. Link the double MX-28 sub-assembly to the spine with 16 M2 Bolts and pass the 200mm cable between the 2 parts. Connect the motors. Put two M2.5 nuts on bust_x motor and fix the i101-Set_to_MX28_link at the same location with 4 M2.5 Bolts. Assemble the the chest with the double rotation MX28 with 16 Bolts M2. Be careful of the part orientations: poppy logo faces front ; spine curvature faces rear. Plug bust_x to the 3P PCB HUB with the 200mm cable, and glue the hub with hot glue right above the chest axis. Than assemble the trunk on top of the tabletop support with 8 M2 bolts. Spine sub-assembly videos Spine sub-assembly Final torso assembly Be careful: this video showcase the torso of a Poppy Humanoid. As a consequence, the bottom spine is not to be mounted in your robot, use the tabletop support instead. 6.4. Assembly of both arms Plug the SMPS2Dynamixel on the last pin of the 3P PCB HUB with the 60mm wire. Fix the shoulders on their side with 16 M2x3 bolts. Fix the right arm on the right shoulder with 32 M2x3 bolts. Repeat on the other side Note IMPORTANT: When you assemble the arm, it must be perpendicular to the body, so that the 3 dots match as usual Next: 7. Head assembly >> Questions ? We're always happy to help with code or other questions you might have! You can ask questions and share solutions on our community Forum. "},"assembly-guides/poppy-torso/head_assembly.html":{"url":"assembly-guides/poppy-torso/head_assembly.html","title":"Head assembly","keywords":"","body":"7. Poppy Torso: Head Assembly Bill of Material for the head 3D printed parts: Neck (U-shaped part) head-face and back speaker right and left (if applicable) camera_support screen_support screen fake_manga_screen Actuators : 1x Robotis Dynamixel AX12A Cables: 1x 3P 140mm Robotis parts: 13x Nuts M2 4x Nuts M2.5 18x bolts S1 1x bolts S-B 4x Bolts M2.5x6 3x Bolts S2 Head assembly instructions Prepare and configure this motor: Sub-assembly name Motor name Type ID Free horn Head head_y AX-12A 37 No Fix the neck on the head_y motor with 4 S1 Bolts. Fix head_y on the neck with 4 S1 Bolts and a S-B Bolts. Plug head_y on the 3P PCB HUB with the 100mm cable Insert the back part of the head on top of head_y. Make sure the axis of head_y is in zero position at this moment: Rely on the marks drawn on the horn and on the motor chassis: they must be aligned. Fix the motor and the head back with 6 S1 bolts. Take the head front, and insert the screen. Insert 4 nuts M2.5 on the top and bottom of the front head. Insert 2 nuts M2 on each side of the front head. Insert the screen support and the fake screen, then fix them with 2 M2.5x6 bolts. Insert the camera support and fix it with 2 M2.5x6 bolts. Fix the left and right speakers on their side with 2 S1 Bolts each. Insert the Raspberry Pi 3 with USB/Ethernet ports facing the rear of the head, on top of its 4 pillars of the head_back part. Use bolts and nuts to fix it as well. Do not close the head before full startup As you might expect, the last part is to add the head_face in order to close the head. However, since the first startup may require debugging, we advise you to keep the head open till you are guaranteed your robot is assembled the right way. Go on with the wiring arrangement. Once you're done with debugging, close the head: Insert a nut M2 on the top, on the bottom left and, on the bottom right of the head front and join the 2 parts of the head and fix them with 3 S2 Bolts. Next: 8. Wiring arrangement >> Older head versions with Odroid Former versions of Poppy Torso were shipped with Odroid U3 or Odroid U4 boards. These boards are no longer supported. If you have such boards, please refer to the archieved documentation for U3 or for XU4. Questions ? We're always happy to help with code or other questions you might have! You can ask questions and share solutions on our community Forum. "},"assembly-guides/poppy-torso/wiring_arrangement.html":{"url":"assembly-guides/poppy-torso/wiring_arrangement.html","title":"Wiring arrangement","keywords":"","body":"8. Poppy Torso: wiring arrangement 8.1. Data and power buses Before you can startup your robot, let's have a look at the cables. Your motors are all connected on a data bus, The drawing below shows the data bus: cables connecting motors are in red, they all connect to the Dynamixel PCB hub in green, including the SMPS power injection and cable of the USB2AX adapter. The USB side of the USB2AX adapter has to be plugged to the USB socket of the Raspi3 at the bottom of the head. 8.2. Power supplies for Poppy Torso The robot requires 2 power supply cables: 12V power supply for the SMPS2Dynamixel of the motors 5V micro USB power supply for the Raspberry Pi 3 For now you can plug both cables to the robot but wait a bit before connecting them to the wall socket. Indeed, there's a few things we need to setup before we can start the software. 8.3. Connect to the robot Let's getting started with software! Please checkout the dedicated section: Getting started with Poppy software. Psst, before you leave: don't forget to fasten the last screws to fix your head face after you got it working from software. Next: 9. Getting started with Poppy software >> Questions ? We're always happy to help with code or other questions you might have! You can ask questions and share solutions on our community Forum. "},"assembly-guides/poppy-humanoid/":{"url":"assembly-guides/poppy-humanoid/","title":"Assembler Poppy Humanoid","keywords":"","body":"Guide d’assemblage de Poppy Humanoid Mise en garde Le guide d'assemblage de Poppy Humanoid n'est disponible qu'en anglais à cet emplacement. Si vous souhaitez aider à la traduction, consultez ce document. Bon assemblage ! Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"assembly-guides/poppy-humanoid/warnings.html":{"url":"assembly-guides/poppy-humanoid/warnings.html","title":"PRIMORDIAL warnings","keywords":"","body":"Primordial warnings to assemble a Humanoid Ignoring these warnings will necessarily lead to a non-working robot and broken hardware It is primordial that your read and understand these warnings below before doing anything with your hardware. PRIMORDIAL warning #1 : Align the horn with the motor axis When a Dynamixel motor is sold, its horn (the metallic wheel) is shipped separately from the motor iself. It is your role to assemble it on the axis. The active horn has to be assembled by respecting precisely the alignment thanks to the marking as in the pictures below. With MX-28 and MX-28AT motors, the horn is assembled by forcing on it. Hence, if you make a mistake, you will not be able to come back. Be sure of the alignement before forcing with the central screw. PRIMORDIAL warning #2: Don't use too much thread locker Thread locker is included in your kit. Place some thread locker at the tip of all screws to prevent vibrations from untying the screws. However, dipping the extremity of the screw on the thread locker is enough (a drop for each screw hole is too much). Otherwise disassembling your robot can be very hard or impossible! If you're unsure, don't use the thread locker in a first step, it will always be possible to put it later when you know your robot better. PRIMORIDAL warning #3: Align the horn with 3D-printed parts Notice that horns all have 3 dots and that the 3D-printed parts also have them close to motor axes. Generally, the opposite axis of the motor axis is a free wheel and 3D-printed parts do not have any point in that side ; except for symmetrical parts such as the legs, that have 3 points on both sides. According to the 3D printing technique, the 3 dots might not been easily visible. Some parts, such as the feet, only have 1 visible point because the parts are hollowed the other side. You must align the horn with the 3D-printed parts by matching the 3 points as the picture below. Warning #4: All parts have an unique orientation It is very easy to get trapped by inserting a motor or a part the wrong way. If you do not pay attention you might find that your assembly is correct because holes align well with pieces but they might be incorrect. Don't worry, except for the first and second primordial warnings, your robot can always be disassembled. In order to minimize the risk of mistakes, compare scrupulously your sub-assembly with pictures and videos at each assembly step. These prominent visual elements should help: The position of motor axis (active wheel) vs the position of the free wheel The position of the motor's sticker The position of the motor's electrical connector The curvature of 3D-printed parts Warning #5: Your robot is sensitive to interferences If you meet sporadic communication issues with motors such as DxlError or timeout, it is possible that interferences perturbate your robot. Here are fixes to attempt: Change the motor cables: Motor cables heat and their conductive properties are getting worse over time. A typical example is when you feel that the cable is more rigid than a brand new cable It may be useful to cut the central wire of the cable directly connected to the USB2AX (and only that one). Indeed, it is known that it can create interferences and this wire (+12V) is unused at this location. Next >> 2. Bill Of Material (BOM) Questions ? We're always happy to help with code or other questions you might have! You can ask questions and share solutions on our community Forum. "},"assembly-guides/poppy-humanoid/bom.html":{"url":"assembly-guides/poppy-humanoid/bom.html","title":"Bill Of Material (BOM)","keywords":"","body":"2. Poppy Huamnoid Bill of Material Checkout the list of components you need and have a look at your own kit to check that nothing is missing. Your robot is composed of: biped legs + torso + head, thus the BOM is divided in 3 parts. Prepare a clear workbench that you may keep busy for a few days with all of these. 1. Biped legs BOM 3D Printed parts: Pelvis left hip right hip left thigh right thigh 2x shin (symmetrical part ; displayed as Leg on the picture) left foot right foot Actuators: 8x Robotis Dynamixel MX28-AT (or MX28-T) 3x Robotis Dynamixel MX64-AT (or MX64-T) Robotis parts: 8x HN07-N101 6x HN07-I101 2x HN05-N102 2x HN05-I101 1x Bioloid 3P Hub Cables & bolts ... Motor configuration: 2x 12V power supply 2x SMPS2Dynamixel 2x USB2AX 2. Multiarticulated torso BOM 3D Printed parts: Chest Spine Abdomen Double rotation MX64 Set (3 parts) Double rotation MX28 Set (3 parts) Actuators: 1x Robotis Dynamixel AX12-A (or AX18-A) 5x Robotis Dynamixel MX28-AT (or MX28-T) 2x Robotis Dynamixel MX64-AT (or MX64-T) Robotis parts: 5x HN07-N101 3x HN07-I101 2x HN05-N102 2x HN05-I102 1x Bioloid 3P PCB HUB 2x SMPS2Dynamixel Motor configuration: 1x 12V power supply 1x USB2AX 3. Head BOM (Raspberry Pi 3 version) 3D Printed parts: 1x Head face 1x Head back 1x Fake manga screen (flat fake screen if no actual screen is mounted) 1x Screen support 1x Camera support 1x Speaker left support 1x Speaker right support 1x Neck Actuators: 1x AX-12 or AX-18 Electronics: 2x Speaker 1x Audio amp 1x Raspberry Pi 3 + its SD card 4. Tools Please note that you will also need: an external computer running Linux Windows or MacOS screwdrivers (crosshead and Torx) tweezer hot glue 5. STL files for Poppy Humanoid 3D printing If you are in the process of 3D-printing the parts from this BOM by yourselves, download the latest STL files from: Poppy minimal head design STLs Poppy Humanoid STLs In order to clone these repositories, please use git lfs to retrieve assets such as 3D parts and images. By cloning the repositories with git only, the assets would appear to be corrupted/invalid files. Next >> 3. Dynamixel hardware Questions ? We're always happy to help with code or other questions you might have! You can ask questions and share solutions on our community Forum. "},"assembly-guides/poppy-humanoid/dynamixel_hardware.html":{"url":"assembly-guides/poppy-humanoid/dynamixel_hardware.html","title":"Dynamixel hardware","keywords":"","body":"3. Mounting Dynamixel horns The Poppy Humanoid robot is mainly built with MX-28AT Dynamixel servomotors (MX-28T are the previous version and can be used without any problem). The other servomotors are MX-64T which are bigger and stronger, and AX-12A or AX-18 which are smaller, used only for the head. Each Dynamixel servomotor embeds an electronic board allowing it to receive different kind of orders (about goal, torque...) and communicate with other Dynamixel servos. Therefore, you can chain up several Dynamixel servomotors (each with a different ID) and command them all from one end of the chain: each servomotor will pass the orders to the next one. Parts used along with Dynamixel motors Here is a table of the parts needed to mount the horns of the motors. Servomotor main horn free horn big horn screw horn screws case screws AX12-A none none M3x10mm M2 M2 MX28 HN07-N101 HN07-I101 M2.5x8mm M2x3mm M2.5x6mm MX64 HN05-N102 HN05-I101 M3x8mm M2.5x4mm M2.5x6mm You will need an allen wrench of size 1.5mm for M2 screws, 2mm for M2.5 screws and 2.5mm for M3 screws. The longer M2 screws need a Phillips screwdriver. Mounting and aligning the active horns Don't mount the horns now, you should do it all along the assembly when a motor is needed. This is only general information, not all motors need to be mounted the same way: with or without rear wheel, with or without nuts ; this will be indicated in the videos for each specific motor. When you receive your Dynamixel servomotors, the horns and their washers are not mounted. The latter are included in the same packaging if the servo is packaged alone or they are packaged separately for 6-pieces bulks. On top of the active motor axis (the axis that is driven by the motor), you will mount the horn and the washer (the white washer for the MX-28). As you already read in the PRIMORDIAL warnings #1 and #3 be very careful about the horn alignement both with the active motor axis and the structural part (3D printed). Here are other views of what you need to achieve: Then you can force on the horn to insert it and use a screw (the longest model) with very few thread locker to fix it. But, again, this is definitive. If you are unsure that you have well aligned the active horn If you are unsure that you have well aligned the horn: Install Poppy software and invoke Poppy Configure with the name of a motor of the same model (MX28/MX-28AT or MX-64) so that it goes to its zero angle. If, after setting your motor to zero angle, the horn does not point upwards as in the image below, then you made a mistake in horn alignment. If you made a mistake in the active horn alignment If you assembled the horn and forced without aligning it correctly, you have two solutions: The offset can be compensated from software in the configuration file of your creature, but this is an advanced operation and you first need to know how much the offset is You can attempt to remove the horn. You will necessarily damage the motor, so be very cautious in order to minimize damages. Proceed as follows: Use a flat screwdriver with a tip of about 2mm in length Remove the center screw if any and carefully slip the tip under the horn Apply a slight rotative pressure pressure on you screwdriver Rotate the horn of 45° and apply another pressure there as shown on the picture Pursue pressures evert 45° all around the horn by keeping your screwdriver always inserted at the same location in order to minimize damages of the black chassis and the washer When the horn is disengaged of about 2mm from the motor (you screwdriver is too narrow to force again), you should be able to pull the horn by hand by pulling very straight and shaking slightly Re-insert then the active horn properly Particular cases of horn alignment according to motor types Horns of motors AX-12 and AX-18 are also oriented but motors are shipped with the horn pre-assembled so there is no danger. Horns of motors MX-64 and MX-64AT are also oriented but horns can be removed easily with no damage to the motor. Thus, the assembly of motors MX-32 and MX-32AT are the most at risk. Mounting the rear horn (free wheel) In most cases, on the other side of the active/driven horn with the 3 dots, you will have to mount another horn with ball bearings. There is no important alignement on this side, this is just a free wheel. Insert a long screw with very few thread locker. However check that this horn rotate very easily by hand, just as a free wheel would rotate when mounted on a ball bearing. A locked free wheel would prevent the motor from moving. Inserting the nuts Some nuts will have to be inserted in the motors in order to receive the screws allowing the 3D printed parts to be fastened. The location needing nuts will be told in the videos for each motor. In order to place a single nut: Take a nut using thin tweezers and bring it in the sitewith the right orientation. Put the end of the tweezers in the hole to ensure good alignment. Then use flat pincers to adjust the nut. These nuts correspond to diameter 2.5mm screws, Allen wrench 2mm. Older motor version MX-28 have no thread at all, but newer version MX-28AT are partially threaded in a side. So less nuts will be needed with newest motors. Later on, when you tighen the screw, make attention not to push the nuts unintentionally. Once motors are inserted in some structural parts, som nut locations can no longer be reached by hands so you will not be along to insert the fallen nuts again. Next >> 4. Configuring the Dynamixel motors Questions ? We're always happy to help with code or other questions you might have! You can ask questions and share solutions on our community Forum. "},"assembly-guides/poppy-humanoid/addressing_dynamixel.html":{"url":"assembly-guides/poppy-humanoid/addressing_dynamixel.html","title":"Configuring the Dynamixel motors","keywords":"","body":"4. Configuring the Dynamixel motors Every Dynamixel motor has its own configuration including: its digital identifier (e.g. id=21, this is the right hip motor) its baudrate: the speed of communication its return delay time: By default all brand new motors have an id = 1 with default communication parameters, so all motors need to be configured one-by-one in order to be attributed their right parameters. Naming convention To simplify the configuration, all Poppy motors are named (e.g. right_hip_x) as shown on the naming convention below. It means that given a motor name, software can deduce the right configuration parameters. Connect a single motor to configure it Configuring a single motor requires 1x SMPS2Dynamixel (SMPS) adapter, 1x USB2AX adapter, 1x 12V power supply, and 2x Dynamixel cables. The USB2AX USB adapter allows some computer (the Raspberry Pi or another computer) to communicate with the motors. The SMPS adapter injects power from the wall socket to the data bus, because such powerful motors cannot be powered from USB only. They must be connected this way: Then plug the USB to your computer and the 12V power adapter to the wall socket. Note Removing the central wire of the cable connected to the USB2AX (and only this one) is optional. It is something advised to do it in case of interferences on the data bus Install the driver for the USB2AX adapter On Linux/MacOS On Linux/MacOS, no installation is needed, but you must add yourself in the group which own the USB serial ports. It is \"dialout\" or \"uucp\" depending on your distribution: sudo addgroup $USER dialout sudo addgroup $USER uucp Then you need to logout from your session and login again. On Windows Instructions for Windows ar available here. Use a software to configure the connected motor There are 3 different software tools to configure your motors one-by-one: Poppy Configure: Command-line tool that only requires to provide the motor name Herborist: Graphical tool used in the videos in place of Poppy Configure Dynamixel Wizard: windows-only tool provided by Robotis. You can use whichever one as long as you manage to configure your motor, but we advise Poppy Configure: Poppy Configure Poppy Configure is a command-line tool to configure Poppy motors that is handy because it only requires the name of the motor to configure it. It is pre-installed on the Raspberry Pi image, so you can plug a HDMI monitor and use it in a terminal, but you may also use another computer, as long as you first install Poppy software. Open a terminal In order to use Poppy Configure you need a terminal: If you installed Poppy software by yourself, you probably know how to locate your system terminal and open it If your robot software was preinstalled, open the welcome page at http://poppy.local, select Python, terminal or Programming, Python and then click on New, terminal as shown below: Your terminal is the black area that you see, in which you can type commands and visualize their output: Configure a motor To configure a motor with Poppy Configure, type the command poppy-configure humanoid in which you replace the motor name by the corresponding one. It will only work if either a Pixl board or a USB2AX adapter is connected to a motor (and only one). Poppy Configure will configure the motor with the right configuration and then move to zero (angle = 0 degree). We strongly advise you to make advantage of that to double-check that the horn is properly aligned with the motor axis: at 0 degree, the single dot must point upwards. NoteIf Poppy Configure displays such error message: poppy-configure: error: argument robot: invalid choice: 'humanoid', then you have missed the installation of the humanoid creature. Use command pip install poppy-humanoid to fix it. Herborist Herborist can be installed with pip once you have setup a Python environment in your computer: pip install herborist Then, type this command to launch it: herborist Connect each motor one by one to the USB2AX and use the ’scan’ button in Herborist or Dynamixel Wizard to detect it. If it’s a new motor, it should have ID 1 and baudrate 57600bps, apart from AX-12A servos which already have a 1000000 baudrate. You have to set: The digital ID corresponding to the naming convention Baudrate to 1 000 000 bps Return delay time to 0 ms instead of 0.5 ms In Herborist, don’t forget to click on the ’Update EEPROM’ button so the changes are taken in account. When should I configure a motor? Don't make the configuration of all motors now, it is advised to configure a motor each time you mount it into the mechanical structure. NoteYou can setup the configuration of a motor as many times as needed. So there is no danger at making confugration attempts now to check that everything is alright Next : 5. Arms assembly >> Questions ? We're always happy to help with code or other questions you might have! You can ask questions and share solutions on our community Forum. "},"assembly-guides/poppy-humanoid/arms_assembly.html":{"url":"assembly-guides/poppy-humanoid/arms_assembly.html","title":"Arms assembly","keywords":"","body":"5. Poppy humanoid: Arms assembly Right arm Bill of Material for the right arm 1x Upper arm + Right hand Right Forearm 1x Arm connector Cables: 1x 3P 200mm 1x 3P 140mm Robotis parts: 4 nuts M2 4 Bolts S1 3x HN07-N101 2x HN07-I101 22x Bolts M2x3 26x Bolts M2.5x6 13x Nuts M2.5 Right arm videos Forearm assembly Upper arm assembly Arm/shoulder assembly Final right arm assembly Motor configuration for the right arm Prepare and configure these motors, all with active horns (HN07-N101), and also the free horn (HN07-I101) when indicated. Sub-assembly name Motor name Type ID Free horn Right upper arm/shoulder r_shoulder_x MX-28AT 52 Yes Right upper arm r_arm_z MX-28AT 53 No Right upper arm r_elbow_y MX-28AT 54 Yes Assembly of the right arm Take the right hand and the right forearm. Insert 4 nuts in the hand, then link the 2 parts with the 4 Bolts S1. Insert 5 nuts M2.5 on motor r_elbow_y on the bottom, 4 on the other side. Plug a 140mm cable to r_elbow_y, drag it in the upper-arm and fix it with 18 bolts M2.5. Drag the motor r_arm_z on the top of the upper arm and fix it. Then connect the motors. Fix the arm connector at the top, and the forearm at the bottom with 22 bolts M2. Put 4 nuts M2.5 behind on the bottom of r_shoulder_x. Fix r_shoulder_x on the arm connector with 8 Bolts M2.5 and thanks to the 200mm cable, connect both motors. Left arm Bill of Material for the left arm 1x Upper arm Left hand + Left Forearm 1x arm connector Cables: 1x 3P 200mm 1x 3P 140mm Robotis parts : 4 nuts M2 4 Bolts S1 3x HN07-N101 2x HN07-I101 22x Bolts M2x3 26x Bolts M2.5x6 13x Nuts M2.5 Left arm videos Forearm assembly Upper arm assembly Arm/shoulder assembly Final left arm assembly Motor configuration for the left arm Prepare and configure these motors, all with active horns (HN07-N101), and also the free horn (HN07-I101) when indicated. Sub-assembly name Motor name Type ID Free horn Left upper arm/shoulder l_shoulder_x MX-28AT 42 Yes Left upper arm l_arm_z MX-28AT 43 No Left upper arm l_elbow_y MX-28AT 44 Yes Assembly of the left arm Insert 5 nuts M2.5 on motor r_elbow_y on the bottom, 4 on the other side. Plug a 140mm cable to l_elbow_y, drag it in the upper-arm and fix it with 18 bolts M2.5. Drag the motor l_arm_z on the top of the upper arm and fix it. Then connect the motors. Fix the arm connector at the top, and the forearm at the bottom with 22 bolts M2. Put 4 nuts M2.5 behind on the bottom of l_shoulder_x. Fix l_shoulder_x on the arm connector with 8 Bolts M2.5 and thanks to the 200mm cable, connect both motors. Next >> 6. Trunk assembly >> Questions ? We're always happy to help with code or other questions you might have! You can ask questions and share solutions on our community Forum. "},"assembly-guides/poppy-humanoid/trunk_assembly.html":{"url":"assembly-guides/poppy-humanoid/trunk_assembly.html","title":"Trunk assembly","keywords":"","body":"6. Poppy Humanoid: Torso assembly 6.1. Chest Bill of Material for the Chest 3D printed parts: Chest Actuators: 1x Robotis Dynamixel AX12-A 2x Robotis Dynamixel MX28-AT Cables: 1x 3P 100mm 2x 3P 140mm Robotis parts : 10x Nuts M2 10x Bolts M2 16x Bolts M2.5 2x HN07-N101 1x Bioloid 3P PCB HUB Chest videos Chest assembly Chest assembly instructions Prepare and configure these motors, all with active horns (HN07-N101 for MX-28AT), without free horns. Sub-assembly name Motor name Type ID Free horn Chest head_z AX-12A 36 No Chest l_shoulder_y MX-28AT 41 No Chest r_shoulder_y MX-28AT 51 No Insert the 10 M2 nuts all around the bottom part of the AX12-A. Lay the AX12-A on the top of the chest, then screw it with the 10 Bolts M2 and plug the 100m cable on the AX12-A, and fix it by passing it in the gap. Plug a 140mm cables between r_shoulder_y and l_shoulder_y. Insert them in their slots in the chest and fix them both with 8 Bolts M2.5. Pass both the 140mm cable in the gap on each side of the chest. Plug the 3 cables on the 3P Extension PCB, with hot glue, fix it behind the chest on top of the Poppy logo. 6.2. Double Dynamixel MX-28 sub-assembly Bill of Material for the Double MX-28 sub-assembly 3D printed parts: 1x i101-Set_to_MX28_link 2x double_rotation_MX28_link Actuators: 2x Robotis Dynamixel MX28-AT Cables: 1x 3P 60mm Robotis parts : 8x Nuts M2.5 8x Bolts M2.5 2x HN07-N101 2x HN07-I101 Double MX-28 sub-assembly videos Double MX-28 assembly Double MX-28 sub-assembly instructions Prepare and configure these 2 motors, both with active horns (HN07-N101). Only one requires its free horn (HN07-I101) but an additional free horn is needed during the sub-assembly. The additional free horn will be mounted to its motor later on. Sub-assembly name Motor name Type ID Free horn Double MX28 bust_y MX-28AT 34 Yes Double MX28 bust_x MX-28AT 35 No Insert a 2.5 nut on the back of the i101-Set_to_MX28_link, and install the second free horn HN07-I101 on it with a central screw. On both double_rotation_MX28_link parts, insert 2 M2.5 nuts. Install them on the bust_x motor. Connect both motors together with the short 60mm cable. Insert 2 M2.5 nuts on bust_y on the same side of the cable. Approach both motors so that their axes form a 90° angle, and fix them by the means of the double_rotation_MX28_link and 4 M2.5 bolts. 6.3. Spine sub-assembly Bill of Material for the Spine 3D printed parts: Spine Actuators : 1x Robotis Dynamixel MX28-AT Cables : 2x 3P 200mm Robotis parts : 4x Nuts M2.5 8x Bolts M2.5 1x HN07-N101 40x Bolts M2x3 4x Bolts M2.5x4 Spine sub-assembly instructions Prepare and configure this motor with its active horn: Sub-assembly name Motor name Type ID Free horn Spine abs_z MX-28AT 33 No Insert 4 nuts in the top face of abs_z. Plug it to a 200mm cable and slide the motor into its slot in the spine. Fix it with the 8 M2.5 Bolts. Link the double MX-28 sub-assembly to the spine with 16 M2 Bolts and pass the 200mm cable between the 2 parts. Connect the motors. Put two M2.5 nuts on bust_x motor and fix the i101-Set_to_MX28_link at the same location with 4 M2.5 Bolts. Assemble the the chest with the double rotation MX28 with 16 Bolts M2. Be careful of the part orientations: poppy logo faces front ; spine curvature faces rear. Plug bust_x to the 3P PCB HUB with the 200mm cable, and glue the hub with hot glue right above the chest axis. Spine sub-assembly videos Spine sub-assembly The video of the insertion of the double MX28 sub-assembly is included to the Full trunk assembly here under 6.4. Double MX-64 sub-assembly Bill of Material for the Double MX-64 sub-assembly 3D Printed parts: 1x i101-Set_to_MX64_link 2x double_rotation_MX64_link Actuators: 2x Robotis Dynamixel MX64-AT Cables: 1x 3P 100mm Robotis parts: 2x HN05-N102 2x HN05-I101 13x Nuts M2.5 12x Bolts M2.5x6 1x Bolts M2.5x8 Double MX-64 sub-assembly instructions Prepare and configure these 2 motors, both with active horns (HN05-N102). Only one requires its free horn HN05-I101 but an additional free horn is needed during the sub-assembly. Sub-assembly name Motor name Type ID Free horn Double MX64 abs_y MX-64AT 31 Yes Double MX64 abs_x MX-64AT 32 Detailed textual instructions are missing, please follow the videos. Double MX-64 sub-assembly videos Double MX-64 assembly 6.5. Full trunk Fix the abdomen part to the abs_z motor. Insert the double MX-64 sub-assembly inside the abdomen ; be careful about the orientation: abs_y faces front while abs_x faces rear ; and abs_z is slightly closer to the front than the rear. Fix the SMPS2Dynamixel with hot glue at the rear of the robot. Full trunk assembly videos Full trunk assembly (includes the double MX-32 insertion) 6.6. Final torso (full trunk with arms) Bill of Material for the Final Torso Sub-assemblies: Full trunk Left arm Right arm 3D printed parts: Left shoulder Right shoulder Cables: 2x 3P 200mm 1x 3P 60mm Robotis parts: 48x Bolts M2x3 SMPS2Dynamixel Final torso videos Final torso assembly Final torso instructions Plug the SMPS2Dynamixel on the last pin of the 3P PCB HUB with the 60mm wire. Fix the shoulders on their side with 16 M2x3 bolts. Fix the right arm on the right shoulder with 32 M2x3 bolts. Repeat on the other side Note IMPORTANT: When you assemble the arm, it must be perpendicular to the body, so that the 3 dots match as usual Next: 7. Legs assembly >> Questions ? We're always happy to help with code or other questions you might have! You can ask questions and share solutions on our community Forum. "},"assembly-guides/poppy-humanoid/legs_assembly.html":{"url":"assembly-guides/poppy-humanoid/legs_assembly.html","title":"Legs assembly","keywords":"","body":"7. Poppy Humanoid: Legs assembly 3D printed parts required: 7.1. Pelvis: Sub-assembly name Motor name Type ID Pelvis l_hip_x MX-28AT 11 Pelvis r_hip_x MX-28AT 21 /!\\ The instruction shows M2x5mm screws. Use the M2x6mm screws that you can find in the Bolt-nut set BNS-10. Pelvis assembly Instructions >> 7.2. Left leg: Sub-assembly name Motor name Type ID Left hip l_hip_z MX-28AT 12 Left hip l_hip_y MX-64AT 13 Left thigh l_knee_y MX-28AT 14 Left shin l_ankle_y MX-28AT 15 Sub-assemblies instructions Left Hip Left Tigh Left Shin If you received your Poppy kit from Generation Robots, you can use the custom 220mm cables instead of really short 200mm cables. Left leg final assembly >> 7.3. Right leg Sub-assembly name Motor name Type ID Right hip r_hip_z MX-28AT 22 Right hip r_hip_y MX-64AT 23 Right thigh r_knee_y MX-28AT 24 Right shin r_ankle_y MX-28AT 25 Sub-assemblies instructions Right Hip Right Tigh Right Shin If you received your Poppy kit from Generation Robots, you can use the custom 220mm cables instead of really short 200mm cables. Right leg final assembly >> 7.4. Legs/pelvis assembly >> 7.5. Legs/Torso assembly Preparation: 5 min Assembly: 5-10 min VIDEO INSTRUCTIONS Next: 8. Head assembly >> Questions ? We're always happy to help with code or other questions you might have! You can ask questions and share solutions on our community Forum. "},"assembly-guides/poppy-humanoid/head_assembly.html":{"url":"assembly-guides/poppy-humanoid/head_assembly.html","title":"Head assembly","keywords":"","body":"8. Poppy Humanoid: Head Assembly Bill of Material for the head 3D printed parts: Neck (U-shaped part) head-face and back speaker right and left (if applicable) camera_support screen_support screen fake_manga_screen Actuators : 1x Robotis Dynamixel AX12A Cables: 1x 3P 140mm Robotis parts: 13x Nuts M2 4x Nuts M2.5 18x bolts S1 1x bolts S-B 4x Bolts M2.5x6 3x Bolts S2 Head assembly instructions Prepare and configure this motor: Sub-assembly name Motor name Type ID Free horn Head head_y AX-12A 37 No Fix the neck on the head_y motor with 4 S1 Bolts. Fix head_y on the neck with 4 S1 Bolts and a S-B Bolts. Plug head_y on the 3P PCB HUB with the 100mm cable Insert the back part of the head on top of head_y. Make sure the axis of head_y is in zero position at this moment: Rely on the marks drawn on the horn and on the motor chassis: they must be aligned. Fix the motor and the head back with 6 S1 bolts. Take the head front, and insert the screen. Insert 4 nuts M2.5 on the top and bottom of the front head. Insert 2 nuts M2 on each side of the front head. Insert the screen support and the fake screen, then fix them with 2 M2.5x6 bolts. Insert the camera support and fix it with 2 M2.5x6 bolts. Fix the left and right speakers on their side with 2 S1 Bolts each. Insert the Raspberry Pi 3 with USB/Ethernet ports facing the rear of the head, on top of its 4 pillars of the head_back part. Use bolts and nuts to fix it as well. Do not close the head before full startup As you might expect, the last part is to add the head_face in order to close the head. However, since the first startup may require debugging, we advise you to keep the head open till you are guaranteed your robot is assembled the right way. Go on with the wiring arrangement. Once you're done with debugging, close the head: Insert a nut M2 on the top, on the bottom left and, on the bottom right of the head front and join the 2 parts of the head and fix them with 3 S2 Bolts. Next: 9. Wiring arrangement >> Older head versions with Odroid Former versions of Poppy Humanoid were shipped with Odroid U3 or Odroid U4 boards. These boards are no longer supported. If you have such boards, please refer to the archieved documentation for U3 or for XU4. Questions ? We're always happy to help with code or other questions you might have! You can ask questions and share solutions on our community Forum. "},"assembly-guides/poppy-humanoid/wiring_arrangement.html":{"url":"assembly-guides/poppy-humanoid/wiring_arrangement.html","title":"Wiring arrangement","keywords":"","body":"9. Poppy humanoid: wiring arrangement 9.1. Data and power buses Before you can startup your robot, let's have a look at the cables. You must connect wires from motors to motors by forming 2 different buses: Upper body (from head_y to abs_x) Lower body (from r_hip_z and l_hip_z to r_ankle_y and l_ankle_y) These 2 buses are fully disconnected from each other (1), they have their own: Power supply (SMPS2Dynamixel + wall socket) Dynamixel hub to plug up to 6x motors USB2AX The drawing below shows the 2 data and power buses: cables connecting motors are in red, data hubs and SMPS power injection in green. (1) N.B.: If you own a single power supply unit, you may connect both power buses together by adding a 4-wire cable and cutting out its data bus so that only 1 SMPS2Dynamixel is powered, as shown in the video. But this is unnecessary in most cases since robots are sold with 2 power supply units. Both USB2AX adapters have to be plugged to the USB sockets of the Raspi3 at the bottom of the head. If you mess up with wiring, at first startup, software will report missing motors or too much motors or the same bus. 9.2. Power supplies for Poppy Humanoid The robot requires 3 power supply cables: 12V power supply for the SMPS2Dynamixel of the upper body 12V power supply for the SMPS2Dynamixel of the lower body 5V micro USB power supply for the Raspberry Pi 3 For now you can plug the 3 cables to the robot but wait a bit before connecting them to the wall socket. Indeed, there's a few things we need to setup before we can start the software. 9.3. Connect to the robot Let's getting started with software! Please checkout the dedicated section: Getting started with Poppy software. Psst, before you leave: don't forget to fasten the last screws to fix your head face after you got it working from software. Next: 10. Getting started with Poppy software >> Questions ? We're always happy to help with code or other questions you might have! You can ask questions and share solutions on our community Forum. "},"installation/":{"url":"installation/","title":"Installation","keywords":"","body":"Installation En fonction de ce que vous voulez faire, toutes les sections ci-dessous supposent que vous avez le client Zeroconf / Bonjour d'installé sur votre ordinateur. Ce n'est pas obligatoire mais autrement, vous devrez connaitre l'adresse IP de votre robot. Le projet Poppy est vaste, il y a beaucoup de possibilités de chemins d'installation en fonction de ce que vous voulez faire. Vous voulez installer un robot Poppy physique Les robots Poppy sont contrôlées par un petit ordinateur embarqué : un Raspberry Pi ou une carte ODROID. Le système d'exploitation de ces ordinateurs est stocké sur une carte SD (vous pouvez également utiliser un contrôleur MMC pour la carte ODROID). Vous avez deux possibilités : - vous avez déjà une carte SD préchargée avec le système d'exploitation Poppy (fourni par Generation Robots). Vous n'avez rien à installer, vous êtes prêt à aller vers la section assemblage. C'est le cas le plus fréquent. - Vous avez une carte SD vierge, vous devez donc télécharger et graver le système d'exploitation sur la carte SD. Si vous êtes familier à Linux et que vous voulez essayer vous-même nos scripts d'installation (qui peuvent être instable), vous pouvez vous rendre au chapitre installation d'une carte Poppy . Vous voulez essayer des robots Poppy dans un simulateur ou dans le visualiseur web Installation des programmes Poppy sur votre ordinateur Installation du simulateur CoppeliaSim Vous voulez réaliser des travaux avancés avec un robot tangible Si vous voulez installer vous-même le système d'exploitation des robots Poppy avec nos scripts d'installation instables : -Installation d'une carte Poppy Si vous voulez contrôler un robot à partir de votre ordinateur personnel, vous devez: -installer des logiciels Poppy sur votre ordinateur -Installer les drivers USB vers série si vous êtes sous Windows Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"installation/install-zeroconf.html":{"url":"installation/install-zeroconf.html","title":"Installez Bonjour/Zeroconf","keywords":"","body":"Zeroconf / Bonjour Zeroconf, aussi appelé Bonjour ou encore Avahi selon le nom des implémentations Apple et Linux, est une technologie permettant à plusieurs ordinateurs sur un même réseau de dialoguer facilement. En quelques mots : Zeroconf vous permet d'accéder à votre Poppy sous le nom poppy.local sans connaître au préalable son adresse IP Zeroconf vous permet de connecter via un cable Ethernet directement votre robot à votre ordinateur sans nécessiter de routeur ou box intermédiaire, et sans nécessiter de serveur DHCP Info Zeroconf n'est pas obligatoire pour utiliser les robots Poppy, mais il est fortement recommandé car il simplifie grandement leur utilisation. La documentation suppose toujours que Zeroconf est installé. Dans le cas contraire votre ordinateur ne peut pas connaître poppy.local et vous devrez remplacer le terme poppy.local indiqué dans la documentation par l'adresse IP du robot : celle-ci peut être plus ou moins simple à trouver selon votre type de connexion (wifi, ethernet avec routeur, sans routeur, point d'accès, etc), sans compter que si un serveur DHCP se trouve sur le réseau alors cette adresse IP peut changer d'un jour à l'autre. Installation Windows Vous devez installer les Services d'impression Bonjour pour Windows (Oui, c'est un logiciel Apple). Puis n'oubliez pas de redémarrer Windows avant de vous connecter à votre robot. Si vous avez déjà installé un logiciel de la marque Apple comme iTunes ou QuickTime, Bonjour doit déjà être installé. Attention Parfois, même si Bonjour est déjà installé sur votre ordinateur, vous ne pouvez pas vous connecter directement à votre Ergo Jr. Pour résoudre le problème, désinstallez et réinstallez Bonjour. Sur les systèmes GNU/Linux Sur GNU/Linux, vous devez installer avahi-daemon (mDNS) et avahi-autoipd (IPv4LL), il peut ou ne peut pas être installé par défaut en fonction de votre installation. Sous Ubuntu/Debian, exécutez sudo apt install avahi-daemon avahi-autoipd Sous Fedora / CentOS, exécutez sudo yum install avahi-daemon avahi-autoipd Connexion directe : SI vous souhaitez connecter directement votre robot à votre ordinateur au moyen d'un unique câble Ethernet, dans ce cas vous devez ouvrir le gestionnaire réseau (Network Manager) généralement à proximité de l'horloge de votre bureau, puis activer le Lien local seulement. Sous MAC OSX Bonjour est préinstallé sur OSX. Connexion directe : Certains ordinateurs OSX fonctionnent mieux avec un adaptateur Thuderbolt-vers-Ethernet plutôt que USB-vers-Ethernet. Informations avancées : Ce que Zeroconf fait pour vous Nom de domaine local (mDNS) Le client Zeroconf publishe un nom de nomaine décentralisé (mDNS) avec le domaine de premier niveau '.local'. Cela signifie que vous pouvez joindre n'importe quel ordinateur du réseau local à partir de son nom d'hôte en ajoutant .local à la fin, cela remplace l'adresse IP qui elle, n'est ni facile à retenir et peut changer d'un jour à l'autre. C'est pourquoi la documentation de Poppy vous demande de taper http://poppy.local dans votre navigateur, il s'agit simplement de charger la page Web fournie par la Raspberry Pi du robot lui-même. Adresses IPv4 en lien local (IPv4LL) Zeroconf possède également un fonctionnement de serveur DHCP décentralisé IPv4LL, qui permet à de ordinateurs sur un même réseau de s'assigner lui-même une adresse IP sans nécessiter de serveur DHCP central, habituellement fourni par le biais d'un routeur Internet ou d'une box (Livebox, etc). Les adresses IP auto-assignées sont dans l'intervalle APIPA, entre 169.254.0.0 et 169.254.255.255. C'est pourquoi vous trouverez parfois ces inhabituelles adresses IP pour votre robot ou votre ordinateur. Tandis que lorsqu'un serveur DHCP est présent, les adresses IP des machines sont dans les intervalles 10.0.0.0 à 10.255.255.255 ou bien 172.16.0.0 à 172.31.255.255 ou bien, le plus fréquent, 192.168.0.0 à 192.168.255.255. Vous pouvez observer que, si vous activez le hotspot Wifi interne à Poppy, les adresses vont de 10.0.0.0 à 10.255.255. Ainsi, il est possible de connecter directement votre ordinateur à votre robot via un unique câble Ethernet puisqu'il n'est pas nécessaire d'avoir un appareil intermédiaire tel qu'un routeur ou qu'une box pour fournir les adresses IP puisqu'elles sont auto-assignées. Alternatives pour trouver l'adresse IP d'un ordinateur sur votre réseau local Si vous ne pouvez pas utiliser Zeroconf ou qu'il ne fonctionne pas et que vous avez besoin de trouver la bonne adresse IP de votre robot, essayez les méthodes suivantes. Vous pouvez utiliser Fing, célèbre pour ses applications Android et iOS Si vous êtes connecté en Wifi à un point d'accès mobile (sur un smartphone Android ou iOS par exemple), la majorité des points d'accès vous affichent directement la liste des clients connectés ainsi que leur adresse IP Nmap ou arp (seulement sur GNU/Linux et OSX) en ligne de commande. nmap -sn 192.168.1.0/24 arp -an | grep -i B8:27:EB Si un routeur ou une box se trouve sur votre réseau, vous povuez également accéder à son interface Web de gestion, la procédure dépend fortement de votre modèle de routeur. Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"installation/burn-an-image-file.html":{"url":"installation/burn-an-image-file.html","title":"Télécharger et graver l'image système","keywords":"","body":"Flasher le système Poppy sur la carte SD Note Ce chapitre est réservé aux personnes qui veulent contrôler un robot tangible. Si vous avez l’intention de contrôler un robot simulé par ordinateur, veuillez vous référer au parcours d’installation pour le simulateur. Les créatures Poppy sont contrôlées par un petit ordinateur embarqué : un Raspberry Pi ou un Odroid. Le système d’exploitation de cet ordinateur est stocké sur une carte SD (vous pouvez également utiliser une carte MMC pour le Odroid). Vous pouvez être dans 2 cas : Vous avez déjà une carte SD avec le système d’exploitation Poppy (fournie par l’un des distributeurs de Poppy par exemple). Dans ce cas vous pouvez directement passer à l'assemblage sans suivre ce tutoriel Vous avez une carte SD vierge ou bien celle-ci nécessite une mise-à-jour du logiciel Poppy. Dans ce cas il faut donc télécharger et écrire le système d’exploitation sur la carte SD. Info Vous devez avoir un ordinateur avec un lecteur de cartes SD pour écrire l’image sur la carte SD. 1. Télécharger l’image du système d’exploitation Il faut choisir l’image système la plus récente disponible, à télécharger selon votre créature Poppy, dans la section Assets : Ergo Jr Poppy Torso Poppy Humanoid Si vous hésitez entre plusieurs types de fichiers, prenez note que le fichier qu'il vous faut est un fichier image compressé, d'extension .img.zip ou bien .img.7z. 2. Extraire l'image compressée Le fichier que vous avez téléchargé est une archive (au format zip ou 7z) d'une image système Poppy. Le fichier se trouve probablement dans le dossier Téléchargements de votre ordinateur, mais il peut être n'importe où sans problème, sauf sur un disque formaté en FAT32, ce qui causera des erreurs lors de l'extraction. Extrayez l'image avant de continuer. Quelque chose comme clic droit sur le fichier > Extraire Ici convient parfaitement. 3. Graver l’image de système d’exploitation sur la carte SD Muni du fichier image correspondant à votre créature Poppy, vous devez utiliser un outil d’écriture pour l'installer sur votre carte SD. 3. Option A : Graver l’image avec Etcher (logiciel avec une interface graphique, le + facile) Téléchargez et installez Etcher. Ce logiciel fonctionne sur les systèmes d’exploitation Windows (versions Windows 7 ou ultérieure), MAC OSX et GNU/Linux. Insérez la carte SD dans votre ordinateur. Démarrez Etcher Sélectionnez le lecteur de carte SD Sélectionnez l’image extraite de l'archive, d'extension .img (un fichier nommé par exemple 2020-10-23-poppy-ergo-jr.img) Démarrez l'écriture. L’image écrite sur votre carte sera vérifiée automatiquement à la fin de l'opération. S'il n'y a pas d'erreur votre carte SD est prête avec le tout dernier système POppy et vous pouvez maintenant assembler votre robot ! 3. Option B : Graver l’image avec dd (logiciel en ligne de commande, pour les experts) Danger Cette méthode fonctionne uniquement pour GNU/Linux et les systèmes d’exploitation OSX et n’est pas recommandée si vous ne comprenez pas ce que vous faites. Insérez la carte SD et chercher où votre carte SD est montée (/dev/mmcblk0 et/dev/disk2 dans l’exemple qui suit). Adaptez à votre cas et exécutez une de ces commandes. Soyez prudent, vous pourriez effacer l’une de vos partitions disques si vous ne comprenez pas ce que vous faites. Si vous êtes sur un système d’exploitation GNU/Linux : sudo dd bs=1M status=progress if=poppy-ergojr.img of=/dev/mmcblk0 Si vous utilisez OSX ou un autre système d'exploitation basé sur BSD : sudo dd bs=1M status=progress if=poppy-ergojr.img of=/dev/rdisk2 Exécuter la commande sync ; cela garantira que le cache d’écriture est vidé et qu’il est possible de démonter votre carte SD sans causer de corruption des données. Retirez la carte SD du lecteur de carte. S'il n'y a pas d'erreur votre carte SD est prête avec le tout dernier système Poppy et vous pouvez maintenant assembler votre robot ! Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"installation/install-poppy-softwares.html":{"url":"installation/install-poppy-softwares.html","title":"Installer les logiciels Poppy","keywords":"","body":"Installer le logiciel Poppy Mise en garde Si vous souhaitez installer le logiciel d’un robot réel sur une carte embarquée de type Raspberry Pi, allez plutôt au chapitre de démarrage. Cette section vous guidera pour installer le logiciel Poppy sur votre ordinateur personnel. Elle est utile seulement si vous êtes dans l’une de ces situations : vous souhaitez contrôler un robot simulé. Vous souhaitez contrôler une créature Poppy depuis votre ordinateur sans utiliser la carte embarquée fournie (Odroid ou Raspberry Pi). Les créatures Poppy sont contrôlées par du code écrit en langage Python. Selon votre système d’exploitation, vous devrez installer Python et dans tous les cas, vous devrez installer les bibliothèques logicielles requises. 1. Installer Python ... ... sur Windows Téléchargez et installez la dernière version de Python pour Windows (x86-64 executable installer). Prenez soin de cocher la case Add Python to PATH durant l'installation, sinon WIndows ne trouvera pas Python dans les étapes suivantes. Info Poppy fonctionne avec 3.5.x et versions supérieures. Anaconda et Python 2.x.x ne sont plus supportées depuis pypot >= 4.0.0. ... sur Mac OSX Mac OSX est livré avec une distribution Python installée par défaut. Avant d’installer le logiciel Poppy, vous devez installer le gestionnaire de paquets Python pip. Ouvrez un terminal, puis appuyez sur entrée pour exécuter la commande suivante : curl --silent --show-error --retry 5 https://bootstrap.pypa.io/get-pip.py | sudo python ... sur GNU/Linux (Ubuntu, Fedora, Archlinux ...) La plupart des distributions GNU/Linux sont déjà équipées de Python, alors il n'y a rien à installer pour Python, continuez à l'étape suivante. Rempalcez juste la commande pip par pip3 qui forcera l'utilisation de Python 3, car certaines distributions possèdent encore Python 2 en plus de Python 3. 2. Installer les logiciels Poppy Maintenant que Python est installé sur votre système, ouvrez un terminal, puis appuyez sur entrée pour exécuter la commande suivante : pip install poppy-ergo-jr Cela demande à Python d'installer la bilbiothèque relative à Poppy Ergo Jr. Note Remplacez « poppy-ergo-jr » par « poppy-torso » ou « poppy-humanoid » pour installer respectivement un Poppy Torso ou un Poppy Humanoid Mettre à jour le logiciel Poppy sous GNU/Linux N'effectuez pas cette étape si c'est votre première installation. Si vous avez besoin de mettre à jour vos logiciels Poppy, il est conseillé de mettre à jour \"pypot\" (la bibliothèque pour le contrôle des moteurs) et le paquet \"creature\" séparément : Note Remplacez « poppy-ergo-jr » par « poppy-torso » ou « poppy-humanoid » pour installer respectivement un torse Poppy ou un humanoïde Poppy. pip install pypot --upgrade --no-deps pip install poppy-creature --upgrade --no-deps pip install poppy-ergo-jr --upgrade --no-deps Info Pour comprendre les commandes ci-dessus: évitez d’utiliser sudo si vous utilisez l'environnement Python de votre système d'exploitation, cela pourrait créer des conflits compliqués à résoudre l'option --upgrade désinstallera l'existant avant de commencer l’installation l'option --no-deps évitera d’installer les dépendances, c’est utile pour éviter à pip de compiler scipy car cela échouera si vous n'avez pas installé les dépendances GCC et Fortran C'est fini ! Si vous avez réalisé les étapes 1 et 2 et qu'il n'y a pas eu d'erreur spécifique, Poppy est installé sur votre ordinateur ! Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"installation/install-vrep.html":{"url":"installation/install-vrep.html","title":"Installation du simulateur  CoppeliaSim","keywords":"","body":"Installation de l'environnement de simulation robotique CoppeliaSim (CoppeliaSim) Info Vous devez installer les logiciels Poppy avant d'installer l'outil de simulation robotique CoppeliaSim. CoppeliaSim est un simulateur robotique efficace principalement Open source (GNU GPL), qui est distribué sous une licence gratuite pour les établissements scolaires et propose une licence commerciale pour les autres secteurs. Il existe également une version PRO EVAL qui empêche seulement de sauvegarder. Vous n'avez pas besoin de sauvegarder la scène CoppeliaSim pour l'utiliser avec pypot (la bibliothèque Python conçue pour les créatures Poppy), nous vous suggérons donc d'installer cette version sans vous inquiéter d'éventuelles violations de droit d'auteur. Si vous souhaitez modifier la scène CoppeliaSim pour ajouter ou personnaliser une créature Poppy, vous devrez utiliser la version PRO ou la version EDU (la licence éducative). Installation de CoppeliaSim sous Windows Télécharger CoppeliaSim PRO EVAL ou EDU (si vous êtes un établissement scolaire). CoppeliaSim n'étant pas signé, vous devrez valider la fenêtre popup SmartScreen (sur Windows 10) pour commencer l'installation. Pendant l'installation, veillez à installer Visual C++ Redistributable 2010 et Visual C++ Redistributable 2012 . Si les versions de Visual C++ Redistributable 2010 ou Visual C++ Redistributable 2012 sont déjà présent sur votre ordinateur, il est conseillé de les \"réparer\" (il s'agit du processus de ré-installation). Après l'installation, vous pouvez réaliser un test pour vérifier si CoppeliaSim fonctionne bien . Installation sous MAC OSX Attention Ce paragraphe doit être complété. Votre aide est la bienvenue ! Installation sous GNU/Linux Attention Ce paragraphe doit être complété. Votre aide est la bienvenue ! Testez votre installation Ouvrez CoppeliaSim avec un double clic sur l'icône du bureau. Ouvrez l'invite de commande de votre distribution Python (appelé l'Invite de commande de Windows), tapez et validez en appuyant sur entrée pour exécuter la commande ci-dessous : poppy-services --snap --vrep --no-browser poppy-torso` Après une ou deux secondes, vous devez avoir une erreur dans votre invite de commande comme le montre l'image ci-dessous. Si vous passez à la fenêtre CoppeliaSim, un popup apparaît pour vous informer que la simulation utilise des paramètres personnalisés. Cette popup bloque la communication vers l'API Python de CoppeliaSim. Vous devez vérifier que la case \"Do not show this message again\" est bien coché et appuyez sur \"Ok\". Revenez vers l'invite de commande Windows. Vous devez répéter la dernière commande (poppy-services --snap --vrep --no-browser poppy-torso) et cliquez de nouveau sur la fenêtre popup CoppeliaSim (avec la case cochée). Ce processus devra être répété trois fois pour que cela fonctionne bien ! Info Pour vous éviter de retaper la même commande encore et encore, vous pouvez appuyer sur la flèche du haut du clavier pour appeler la dernière ligne entrée. Lorsque la configuration de CoppeliaSim est finie, vous pouvez exécuter la dernière commande sans la dernière partie : \"--no-browser\". poppy-services --snap --vrep poppy-torso Si vous voyez une fenêtre popup de votre pare-feu, comme l'image ci-dessous, assurez-vous de vérifier que \"réseau privé\" est coché. Si tout fonctionne bien, un nouvel onglet a été ouvert sur votre navigateur Web par défaut. Vous pouvez débuter la programmation de votre robot dans Snap! ou en Python. Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"installation/install-drivers.html":{"url":"installation/install-drivers.html","title":"Installer les pilotes USB vers port série","keywords":"","body":"Installer les pilotes Mise en garde Ce chapitre est destiné aux personnes qui veulent contrôler un robot Poppy sans employer une carte embarquée (Raspberry Pi ou Odroid). C’est un cas particulier pour les utilisateurs avancés. Si vous souhaitez contrôler des robots tangibles directement depuis votre ordinateur sans un Raspberry Pi ou un Odroid et que vous utilisez un ordinateur avec Windows (vs GNU/Linux ou MAC OSX), vous devrez peut-être installer manuellement les pilotes pour le USB2AX ou le USB2Dynamixel. Si vous utilisez un USB2AX Si le USB2AX n’est pas reconnu immédiatement (sa LED reste rouge après avoir été branché) sur votre ordinateur, vous devrez probablement installer manuellement ses pilotes. Le processus d’installation et les fichiers à télécharger se trouvent sur la documentation de USB2AX. Vous n'avez pas besoin de pilotes pour GNU/Linux ou MAC OSX, mais notez qu’il ne fonctionne pas très bien avec MAC OSX. Si vous souhaitez commander des moteurs XL-320 (protocole servomoteurs Dynamixel v2) à partir d’une USB2AX, vous devrez peut-être mettre à jour le firmware à la version 04 de la USB2AX. Si vous utilisez un USB2Dynamixel Vous devez installer les pilotes FTDI sur votre ordinateur. Vous devez baisser la « valeur de latence du Timer » de 16ms à 1ms (valeur minimum autorisée) comme expliqué dans la documentation de FTDI pour éviter que les appels pypot fassent un timeout. Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"installation/install-a-poppy-board.html":{"url":"installation/install-a-poppy-board.html","title":"Installer un ordinateur embarqué pour un robot Poppy","keywords":"","body":"Installer un ordinateur embarqué pour un robot Poppy Mise en garde : ce chapitre est destiné seulement aux personnes qui veulent créer de toutes pièces une image système pour Raspberry Pi ou Odroid. Il est fortement conseillé de simplement graver une image système fournie par l'équipe Poppy pour installer les logiciels sur votre robot. Pour installer une carte embarquée pour Poppy, nous partons d’une distribution Linux standard (Debian ou Ubuntu), nous supprimons les logiciels inutiles et lançons quelques scripts. Ayez en tête pas que nos scripts d’installation n'ont pas été conçu pour les utilisateurs finaux : ils ne sont pas forcément à jour et il n’y a presque aucun messages d’erreurs pour vous guider. Si vous rencontrez des problèmes avec ces scripts, vous pouvez poster un message dans la section d’aide du forum Poppy. Pour un Poppy Ergo Jr / Raspberry Pi Les cartes SD Raspberry Pi du commerce sont pré-installées avec le système d'exploitation NOOBS, vous devez tout d’abord installer un système d'exploitation Raspbian. Téléchargez l’image de votre système : * Raspbian Jessie Écrivez l’image sur la carte SD avec un outil d'écriture de disque comme cela est expliqué dans la section démarrage. Ajoutez un nom de fichier vide « .ssh » dans la partition \"boot\" pour activer le SSH. Se connecter sur l'ordinateur embarqué par SSH : ssh pi@raspberrypi.local, mot de passe = raspberry. Note Remarque : Si vous utilisez Windows, vous n’avez pas de client SSH préinstallé. Vous devez télécharger et installer putty ou mobaxterm afin d’utiliser SSH. Vous devrez vous assurer que vous avez assez d’espace libre sur votre Raspberry Pi. Le moyen le plus simple est d’utiliser le script raspi-config pour étendre votre partition et occuper tout l'espace disque disponible sur la carte SD. Connectez-vous sur votre Raspberry et exécutez (vous devrez redémarrer ensuite) : sudo raspi-config Assurez-vous que votre carte est connectée à Internet et utilisez le programme d’installation « raspoppy » : curl -L https://raw.githubusercontent.com/poppy-project/raspoppy/master/raspoppyfication.sh | bash -s \"poppy-ergo-jr\" Note Changezpoppy-ergo-jr dans la commande ci-dessus par la créature Poppy que vous désirez installer sur votre Raspberry Pi. Redémarrez le Raspberry Pi après la fin de l’installation. Le nom d’hôte, utilisateur par défaut et le mot de passe sera « poppy » (ssh poppy@poppy.local mot de passe = poppy). Vous pouvez tester votre installation avec l’interface web dans votre navigateur web en allant sur http://poppy.local. Installer un Poppy Torso / Humanoïde sur un Odroid U3 ou Odroid XU4 Ces ordinateurs embarqués sont équipés de base sur la mémoire MMC d'une image système Ubuntu fonctionnelle, vous pouvez utiliser les scripts d'installation sur celle-ci. Dans le cas où vous n'avez pas de nouvelle installation, vous devez télécharger et graver des images système par défaut suivante: Ubuntu 14,04 pour Odroid U3 Ubuntu 14,04 pour Odroid XU3/XU4 Pour le graver le système d'exploitation sur la carte MMC/SD, regardez la section de démarrage. Maintenant que vous avez une installation fraichement installée, vous pouvez insérer votre carte mémoire dans votre ordinateur embarqué, brancher votre connexion Ethernet, et le mettre sous tension. Connectez-vous à la carte en SSH: ssh odroid@odroid.local, Mot de passe = odroid. Info Si vous utilisez Windows, vous n'avez pas de client SSH natif; vous devez télécharger et installer putty ou mobaxterm pour utiliser le protocole SSH. Assurez-vous que votre carte est connectée à Internet, télécharger et exécuter poppy_setup.sh (remplacer 'poppy-humanoïde' ci-dessous par 'poppy-torso' si vous voulez installer un robot Poppy Torso): wget https://raw.githubusercontent.com/poppy-project/odroid-poppysetup/master/poppy_setup.sh -O poppy_setup.sh sudo bash poppy_setup.sh poppy-humanoid Vous devriez perdre votre connexion SSH en raison du redémarrage de la carte. Ce redémarrage est nécessaire pour procéder à la finalisation du redimensionnement de la partition. Maintenant, votre carte embarqué devrait installer l'environnement Poppy. S'il vous plaît, n’éteignez ni ne coupez pas l'alimentation de la carte. Vous pouvez voir le processus d'installation en vous rebranchant à votre carte avec votre nouveau compte poppy: ssh poppy@poppy.local Mot de passe = poppy. En raison de la compilation de lourds paquets Python (Scipy, Numpy), le processus peut prendre plus d'une heure avant de ce terminer. Un processus va automatiquement prendre le contrôle de votre terminal et afficher les informations d'installation. Vous pouvez sortir avec Ctrl + c. Vous pouvez récupérer les informations en lisant le fichier install_log: tail -f install_log Soyez patient ... À la fin de l'installation, votre ordinateur redémarrera. Vous pouvez consulter le log tail-f install_log, si tout s'est bien terminé, les dernières lignes devraient être: System install complete! Please share your experiences with the community : https://forum.poppy-project.org/ Note: Si vous n'êtes pas sûr de ce qui se passe, vous pouvez voir si le processus d'installation est en cours d'exécution avec: ps up $(pgrep -f 'poppy_launcher.sh') Le nom d’hôte, utilisateur par défaut et le mot de passe sera « poppy » (ssh poppy@poppy.local mot de passe = poppy). Vous pouvez tester votre installation avec l’interface web dans votre navigateur web en allant sur http://poppy.local. Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"programming/":{"url":"programming/","title":"Programmation","keywords":"","body":"Programmation Il y a différentes façons de programmer votre robot Poppy. Ce choix dépend de vos compétences et de vos préférences ! Si c'est votre première expérience de programmation, vous devriez probablement commencer par programmer avec Snap!. Si vous voulez débuter avec Python, consultez Utiliser Jupyter. Si vous voulez approfondir votre robot avec Python, consultez Programmer en Python. Si vous souhaitez utiliser ROS (Robot Operating System) consultez Support expérimental de ROS Si vous voulez contrôler à distance votre robot, regardez la section API des robots. Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"programming/snap.html":{"url":"programming/snap.html","title":"Programmation avec Snap!","keywords":"","body":"Programmer Poppy avec Snap Snap est un langage de programmation visuel permettant de créer des animations et jeux interactifs, et bien plus. Il est directement inspiré de Scratch et permet les mêmes fonctionnalités. C'est le langage de programmation visuel de votre robot Poppy, qui permet aux débutants de découvrir des concepts de logique mathématique et de programmation informatique grâce à des activités ludiques et accessibles. Cette courte introduction est librement inspirée du cours \"Beauty and Joy of Computing\" (BJC: Beauté et joie de la calculabilité) de l'Université de Berkeley. 1. Démarrer Snap sur votre robot 1.a. Si vous n'avez pas de robot mais souhaitez en simuler un avec poppy-simu Il n'est même pas nécessaire d'avoir un vrai robot Poppy entre vos mains pour programmer un robot avec Snap ! Vous pourrez ainsi vous entrainer avant d'avoir un robot tangible. Nous allons utiliser un visualisateur de robot nommé poppy-simu. Warning poppy-simu est seulement compatible avec poppy-ergo-jr. Les autres créatures nécessitent une simulation dans CoppeliaSim (cf 1.c) Il vous suffit d'ouvrir dans 2 onglets différents de votre navigateur : L'interface de programmation Snap sur *simu.poppy-project.org/snap/ Et le visualisateur de robot sur simu.poppy-project.org/poppy-ergo-jr. Passez ensuite au titre 2 ci-dessous pour découvrir l'interface Snap. 1.b. Si vous avez un robot tangible entre les mains Si vous avez déjà démarré votre robot vous connaissez la page http://poppy.local. Si vous ne parvenez pas ou plus à charger cette page reprenez l'étape de connexion du guide d'assemblage. Cliquez simplement sur le bouton Programmation puis \"Snap\" pour démarrer Snap sur votre robot tangible. Si vous venez de démarrer votre robot une popup vous indique que l'API de votre robot est arrêtée et doit être démarrée pour faire fonctionner Snap. Cliquez simplement sur le bouton proposé pour la démarrer. Vous pouvez ensuite charger un projet Poppy : Cliquez sur l'icône Fichier puis Open (Ouvrir) puis Examples (Exemples) puis ouvrez l'un des projets Poppy. Cela peut prendre 5 à 15 secondes pour le charger. Passez ensuite au titre 2 ci-dessous pour découvrir l'interface Snap. 1.c. Si vous voulez simuler aussi l'environnement physique avec CoppeliaSim (avancé) Cette option est réservée aux utilisateurs avancés qui veulent non seulement simuler le robot mais aussi les interactions physiques avec son environnement tel que des balles et des cubes qui pourraient s'entrechoquer via des forces physiques. Poppy utilise le simulateur physique nommé CoppeliaSim. Info Il est d'abord nécessaire avoir installé les bibliothèques Poppy ainsi que CoppeliaSim sur votre ordinateur, consultez le chapitre d'installation. Ouvrez d'abord CoppeliaSim. Pour lancer le Snap et le connecter à CoppeliaSim, utilisez poppy-service. Ouvrez votre terminal système Windows, OX ou Linux puis copiez/collez la commande : poppy-services poppy-ergo-jr --snap --vrep Si nécessaire, substituez 'poppy-ergo-jr' par 'poppy-humanoid' ou 'poppy-torso' pour simuler respectivement un Poppy Humanoid ou un Poppy Torso. Au premier démarrage, un téléchargement automatique de Snap est nécessaire, si vous êtes connecté à Internet il suffit de le laisser fonctionner seul. Quand le téléchargement est effectué, un onglet Snap s'ouvrira dans votre navigateur Vous pouvez aussi ouvrir Snap pour simulateur sur simu.poppy-project.org/snap/ A présent tout ce que vous ferez dans Snap fera bouger votre robot simulé dans CoppeliaSim. Attention Toutes les popup d'information du simulateur vont mettre en pause la connexion avec Snap. Dans ce cas vous pourriez avoir besoin de tuer poppy-services avec les touches Ctrl+C puis les redémarrer. Notez que vous pourriez aussi démarrer poppy-simu de la même manière que pour CoppeliaSim : poppy-services poppy-ergo-jr --snap --poppy-simu poppy-simu est beaucoup plus léger et simple que CoppeliaSim, mais il n'est pas capable de simuler l'environnement physique autour du robot. 2. Découverte de l'interface de programmation Ouvrir un projet Snap Quand vous créer un programme Snap, vous pouvez enregistrer et recharger votre programmer dans un fichier-projet pour le retrouver plus tard. La première chose à faire est d'ouvrir un fichier-projet Poppy si ce n'est pas déjà fait : Cliquez sur l'icône Fichier puis Open (Ouvrir) puis Examples (Exemples) puis ouvrez l'un des projets Poppy. La toute première fois ouvrir un fichier d'exemple et plus tard vous rouvrirez vos propres fichiers projets que vous aurez sauvegardés. Sauvegarder un projet Snap Il y a 3 façons de sauvegarder en cliquant sur l'icône Fichier en haut à gauche de l'itnerface graphique Snap : Enregistrer le projet dans le navigateur Cliquez simplement sur Save (Sauvegarder). Ce programme pourra ensuite être rechargé depuis le même ordinateur et le même navigateur. Il existe un risque que ce programme soit effacé si vous utilisez la fonciton \"Supprimer mes traces de navigation ou cookies\" de votre navigateur. Le cloud Snap Snap vous permet d'enregistrer votre programme sur son cloud, ce qui nécessite de créer un compte. Cela a l'avantage de vous permettre de pouvoir repartager de programme à d'autres personnes en leur communiquant tout simplement le lien vers votre cloud. Créer un compte sur le cloud Snap Cliquer sur le bouton -> \"signup...\". Complétez les champs demandés. Vous recevrez un e-mail de validation avec un mot de passe aléatoire imposé. Vous pouvez ensuite vous connecter avec ce mot de passe. Il est pratique de cocher la case permettant de rester connecté à votre compte cloud sur votre ordinateur. Vous pouvez aussi changer de mot de passe pour en mettre un plus aisé à retenir. Partager votre projet Snap Le principal avantage du cloud SNap est de vous permettre de partager votre projet avec quelqu'un d'autre en partageant un lien. Vous devez d'abord être connecté à votre compte. Puis allez dans le menu Open (Ouvrir) Dans la section \"cloud\", sélectionnez le projet à partager puis cliquez sur Share (Partager). Cliquez de nouveau sur Open (Ouvrir) ... ... puis vous pourrez visualiser et partage votre lien à diffuser à vos collègues ou élèves par un simple copier/coller ! Lorsque quelqu'un ouvrira votre projet de votre cloud, votre projet s'ouvrira en plein écran sur la zone de droite nommée \"Sprite\". Cliquez sur la double-flèche pour restaurer l'interface de programmation Snap habituelle. Importer/Exporter votre projet Snap L'import/export est la façon la plus basique de sauvegarde et réouverture d'un projet Snap via un fichier, tout comme vous sauvegarderiez et réouvririez un document dans un traitement de texte, sauf que c'est un projet Snap pour Poppy ! Les fichiers projet Snap sont de type XML (ils se terminent par .xml). N'essayez pas d'ouvrir ce fichier en le chargeant dans votre navigateur, vous verriez son contenu complètement illisible pour un être humain. Si vous voyez le contenu du fichier alors que vous essayez de le sauvegarder néanmoins, faîtes juste un clic droit au milieu du texte puis cliquez sur \"Enregistrer sous\". Le fichier que vous enregistrerez est un export de votre projet Snap ! Lorsque vous souhaitez réouvrir ce projet (importer), ne double-cliquez pas dessus mais ouvrez Snap comme précédemment expliqué puis allez dans le menu d'import de projet de l'icône Fichier : Chercher les blocs qui concernent Poppy Snap possède dans la barre de gauche tous les blocs qui permettent de programmer Poppy ... et bien plus ! Pour y voir plus clair, ils sont organisé en catégories de couleur. La catégorie jaune Control (Contrôle) comprend une bonne partie des blocs qui permettent de contrôler Poppy. Il est également pratique de taper Ctrl+F ou bien de cliquer sur \"Find blocks\" pour de taper un mot et ainsi filtrer tous les blocs pour trouver celui que vous cherchez. Tester la communication avec le robot Cliquer sur le bloc \"test connection\". est pratique pour vérifier que tout va bien au tout début. Il doit afficher une bulle \"Connection OK\". S'il affiche \"You may have connection troubles\", alors vous avez surement oublié de démarrer l'API du robot dans l'en-tête de la page ou bien si vous utilisez un simulateur la variables \"host\" pourrait être incorrecte. . Liste des blocs pour contrôler Poppy Pour programmer votre robot Poppy avec Snap, vous pouvez utiliser les blocs suivants provenant de la liste à gauche, les faire glisser dans l'espace de composition du programme au centre et les imbriquer les uns dans les autres ou les uns à la suite des autres pour créer le comportement logique souhaité de votre robot. Pour mieux les comprendre en détail, il est conseillé de suivre le livret d'activités pédagogiques fourni avec votre robot puis ensuite suivre les activités avancées en ligne. Description Le bloc à cliquer en premier pour tester la communication avec le robot. Passer un ou plusieurs moteurs en mode mou (compliant) ou rigide (stiff). Si vous souhaiter bouger un moteur manuellement il doit être mou, alors que si vous souhaitez le bouger via des blocs Snap il doit être rigide. Vous devez taper le nom d'un moteur ou bien fournir une list des moteurs à passer en mou ou rigide, grâce au bloc \"list\" Bouger un ou plusieurs moteur à une certainement position angulaire en lui fournissant un angle cible en degrés. Le champ “motor(s)” accepte : - le nom d'un unique moteur ( par ex m1) - une série de plusieurs noms de moteurs séparés par des espaces (par ex m1 m2 m3 m4) - un bloc Snap de type \"list\" comme par ex \"$robot all motors\". “Wait” peut être activé ou désactiver selon s'il faut attendre que le mouvement soit terminé ou non pour passer au bloc suivant.\" Changer la couleur de LED d'un ou plusieurs moteurs. Le champs “motor(s)” accepte : - le nom d'un unique moteur ( par ex m1) - une série de plusieurs noms de moteurs séparés par des espaces (par ex m1 m2 m3 m4) - un bloc Snap de type \"list\" comme par ex \"$robot all motors\". Rejouer le mouvement enregistré sous le nom spécifié en indiquant la vitesse de lecture (1 pour garder la même vitesse, 0.5 pour allez 2 fois plus lentement ou 2 pour aller 2 fois plus vite). Jouer simultanément une série de mouvements. Jouer consécutiement les uns après les autres une série de mouvements. Démarrer l'enregistrement d'un mouvement sous un certain nom (n'oubliez pas d'arrêter l'enregistrement !) | | Arrêter l'enregistrement et le sauvegarder sous le nom spécifié. | | | Arrêter un mouvement en cours de rejeu. | | | Jouer les mouvements en même temps | | | | | | Jouer les mouvements les uns à la luiste des autres | | | Démarrer/Arrêter/ettre en Pause/ ou Reprendre un comportement préenregistré dans le robot. Les comportements sont soit des mouvements, soit des positions cibles, soit des analyses de caméra, soit des boucles sensorimotrices (qui connectent les moteurs sur des capteurs).. | | | Jouer un mouvement à l'envers à la vitesse indiquée | | | Jouer un mouvement à la vitesse indiquée | | | Retourne les moteurs appartenant à un groupe.. | | | Groupe de tous les noms de moteur du robot | | | | Donne la position actuelle de tous les moteurs. Très utile pour enregistrer la position actuelle de tout le robot. | | | Retourne l'indice d'un nom de moteur dans la liste \"all motors\" list. | | | Donne tous les noms de mouvements enregistrés | | | Donne la liste de tous les comportements actuellement démarrés . | | | Donne la liste de tous les groupes moteurs. | | | Donne toutes les fonctions qui peuvent être utilisées dans un comportement (avancé) | | | Renvoie VRAI ou FAUX selon si le QR Code de la carte choisie est actuellement dé&tecté devant la caméra. | | | Donne l'URL du robot (usage avancé) | | | Redémarrer le logiciel du robot | | | Changer la valeur d'un registre moteur (position, speed, max torque, …) ou de plusieurs moteurs. Le champs “motor(s)” accepte : - le nom d'un unique moteur ( par ex m1) - une série de plusieurs noms de moteurs séparés par des espaces (par ex m1 m2 m3 m4) - un bloc Snap de type \"list\" comme par ex \"$robot all motors\". | | Lire la valeur d'un registrer moteur (position, speed, load, ...) (avancé) | | Indiquer l'adresse du robot Poppy à contrôler. ça peut être : robot_name.local (par ex poppy.local) une adresse IP (par ex 123.124.145.176) Il est recommandé de ne pas le modifier si vous ne comprenez pas à quoi cela sert (avancé) | Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"programming/notebooks.html":{"url":"programming/notebooks.html","title":"Utilisation des notebooks Jupyter","keywords":"","body":"Gallerie de notebooks Jupyter : programmer en Python La plupart des exemples d'utilisation de Python avec les robots Poppy sont donnés avec les notebooks Jupyter. Nous encourageons fortement l’utilisation de cette application web, car elle permet la création et le partage de documents mélangeant du code, des éléments visuels et du texte explicatif. Par ailleurs, les notebooks permettent également la conception d'interface pour contrôler le robot en direct grâce à des widgets. Pour chaque notebook, nous fournissons une courte description de qu'il fait, avec quel robot / simulateur il peut être utilisé et bien sûr un lien. Most of the notebooks are written in english but you will also find some in french (and hopefully soon in other languages). Ce chapitre présente une série de notebooks et tente de les organiser en différentes catégories. Premiers pas Découvrez votre Poppy Ergo Jr : Notebook - Comment contrôler le robot, démarrer un comportement préprogrammé, envoyer des commandes moteur, obtenir les valeurs de capteurs ... Controlling a Poppy Humanoid in CoppeliaSim: Notebook - Describe how to setup a Poppy Humanoid in CoppeliaSim and how to control it (motor control and sensor reading) from pypot in Python. Record, Save, and Play Moves: Notebook - Simple introduction on how to record by demonstration moves on any Poppy Creature. It also shows how they can be re-played and saved/load to/from the disk. Notebooks en français 10 choses à savoir avec Poppy Humanoid/ErgoJr et CoppeliaSim: pour l'ErgoJr, pour l'Humanoid - 10 informations de base pour bien commencer avec Poppy Humanoid ou Poppy ErgoJr simulés dans CoppeliaSim et comment les contrôler en Python. Simulator CoppeliaSim Controlling a Poppy Humanoid in CoppeliaSim: Notebook - Describe how to setup a Poppy Humanoid in CoppeliaSim and how to control it (motor control and sensor reading) from pypot in Python. Interacting with objects in CoppeliaSim: Notebook - Show how you can programtically add objects to the CoppeliaSim simulation and interact with them. This example uses a Poppy Torso but can be easily adapted to other creatures. Learning the robot IK: Notebook - Demonstrate how explauto can be used to learn the inverse kinematics of a Poppy Humanoid. The experiments are run in CoppeliaSim simulation but it also gives hints on how it can be transposed in the real world. Notebooks en français 10 choses à savoir avec Poppy Humanoid/ErgoJr et CoppeliaSim pour l'ErgoJr, pour l'Humanoid - 10 informations de base pour bien commencer avec Poppy Humanoid ou Poppy Ergo Jr simulés dans CoppeliaSim et comment les contrôler en Python. HTTP REST API and remote connection Controlling a robot using HTTP requests: Notebook - Show how you can send HTTP requests to a robot, using the REST API, to control it. The notebook is based on a CoppeliaSim simulated Poppy Humanoid but can be adapted to other creatures. Scientific experiments Discover Explauto Learning the robot IK: Notebook - Demonstrate how explauto can be used to learn the inverse kinematics of a Poppy Humanoid. The experiments are run in CoppeliaSim simulation but it also gives hints on how it can be transposed in the real world. Demo interface Primitives launcher for Poppy Humanoid: Notebook - Provides all codes needed to directly launched primitives (stand, sit, idle motions, limit torque...) Education Notebooks en français Initiation à l'informatique en Lycée Découverte: TP1, TP2, TP3 - Comprendre comment faire bouger simplement le robot. Utilisation des boucles. Ces TPs utilisent un Poppy Torso simulé dans CoppeliaSim. Dialogue: TP1, TP2 - Établir un dialogue entre Python et le robot. Ces TPs utilisent un Poppy Torso simulé dans CoppeliaSim. N'hésitez pas à nous faire savoir s'il manque certaines références d'ordinateurs portables! Vous pouvez directement envoyer une pull-request sur GitHub ou utiliser le gestionnaire de bug. Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"programming/python.html":{"url":"programming/python.html","title":"Programmation en Python","keywords":"","body":"Programmation des robots Poppy en Python Ce chapitre vous guidera de manière à pouvoir contrôler les robots Poppy en Python. Comme c'est le langage actuel pour écrire des librairies Poppy, vous verrez comment accéder tous les différents niveaux de contrôle, du plus haut vers le plus bas. Nous allons détailler tout ce que vous devez savoir pour pouvoir programmer directement le robot en utilisant le Python embarqué dans le robot Poppy ou pour l'installer localement. Remarquez que ce chapitre ne prétend pas vous apprendre le langage Python ou la programmation à partir de zéro et donc si vous êtes totalement nouveau sur le langage Python, il peut être bon de commencer avec un tutoriel de Python. Pourtant, nous essayons de garder les tutoriels aussi simples que possible et nous vous avertirons toujours lorsque certaines parties ciblent les utilisateurs les plus avancés. Nous allons essayer de fournir autant d'exemples que possible et de l'axer sur l’API complète ainsi vous pouvez trouver et utiliser les fonctionnalités moins courantes. La plupart des exemples et didacticiels sont disponibles comme une liste de notebooks Jupyter. Le prochain chapitre, Galerie de notebooks Jupyter, présente une liste descriptive de chaque notebook, de ce qu'ils contiennent, comment ils peuvent être utilisés, pour quel robot, etc. Toutes les bibliothèques Poppy sont open source et sont distribués sous la licence GPL v3. Ainsi, vous pouvez accéder librement le code source sur GitHub. N’hésitez pas à créer un fork, envoyer un pull/request et à contribuer ! Pourquoi Python? Les bibliothèques développées pour le projet Poppy ont été conçus dans le but de rendre facile et rapide l’écriture du code de contrôle des différents robots basés sur - à l'origine - les servomoteurs dynamixel robotis. L’idée était de fournir un accès depuis le bas niveau -communication série brute avec un moteur spécifique par exemple- à des niveaux plus élevés tels que le démarrage et l’arrêt de primitives/comportements (p. ex. suivi de visage, postures,...) ou l'enregistrement directement des mouvements grâce à de l’apprentissage par démonstration. Nous avons décidé d’écrire la plupart d'entre eux en Python, car sa souplesse permet un développement rapide et modulaire. Elles étaient également destiné à être accessible par un large public, de développeurs, de roboticiens en général, pour des amateurs, des chercheurs, des artistes... Python a également été choisi pour l'énorme choix de bibliothèques existantes (scientifique, vision par ordinateur, web...), donc si quelqu'un souhaite ajouter un nouvel élément, comme le support à un nouveau moteur/capteur, cela devrait être réalisable le plus facilement et rapidement possible. Enfin, le support multiplateforme et la facilité d’installation étaient également des aspects essentiels. Vue d’ensemble des différentes bibliothèques Info Une documentation plus détaillée de ces bibliothèques logicielles est disponible dans la section bibliothèques logicielles Avant de se lancer dans la programmation, nous allons présenter brièvement les différentes bibliothèques Poppy existantes et comment elles interagissent entre elles. Il y a trois principales bibliothèques logicielles : pypot : C’est le cœur de l’architecture logicielle Poppy. Pypot gère toutes les communications de bas niveau avec le matériel (capteurs et moteurs), définit les boucles de synchronisation afin que votre commande soient toujours à jour. Il fournit également les primitives du mécanisme qui permet la définition d’un comportement simple qui peut être -plus ou moins- automatiquement combinés. poppy-ergo-jr, poppy-torso, and poppy-humanoid: ces bibliothèques sont spécifiques à chaque robot Poppy. Elles définissent la configuration particulière du robot, les capteurs utilisés, quels moteurs sont connectés à quel bus... C’est aussi ici que des comportements spécifiques à une créature sont définis (la primitive qui fait Poppy Humanoid se tenir debout par exemple). Cela est résumé dans le schéma ci-dessous : Installation Tout d’abord, notez que si vous n’envisagez d’utiliser que des robots réels, ils viennent avec Python et toutes les bibliothèques Poppy déjà installées. Vous pouvez vous connecter directement au serveur Jupyter Notebook via l'interface web et n’avez rien à installer sur votre machine ! Ce que vous devez installer est résumé dans le schéma ci-dessous : Ainsi, si vous prévoyez de soit Utiliser un simulateur (p. ex. CoppeliaSim ou simulateur web), ou de brancher le robot à votre ordinateur Vous devrez installer les bibliothèques Poppy localement. Elles fonctionnent sur Windows, Mac OSX, Linux et ont été testées sur Python >= 3.5 Si vous planifiez de brancher votre robot directement suir votre port USB, des pilotes additionnelles devront être installés. Les étapes sont détaillées dans ce chapitre. Pour démarrer : Bonjour Poppy ! Afin de vous donner une vue d'ensemble de ce que vous pouvez faire avec Poppy et Python, cette section va vous montrer comment : Crer et connecter votre robot Consulter les valeurs renvoyées par les capteurs et les moteurs Utiliser les primitives en enregistrant des mouvements Cette section ne prétend pas tout couvrir ce qui est possible mais vous donne un bon bagage de départ. Pour un usage avancé, la section suivante vous présente des cahiers Jupyter Notebook à suivre. Dans ces exemples, nous supposons que vous disposez d'un environnement fonctionnel, càd que vous avez soit : un robot branché avec sa Raspberry Pi : vous utiliser sont interpréteur Python préinstallé via le Jupyter Notebook installé les bibliothèques logicielles de votre créature sur votre ordinateur pour utiliser le simulateur installé les bibliothèques logicielles de votre créature sur votre ordinateur pour utiliser le robot branché en USB Créer et se connecter au robot Importer la bilbiothèque La toute première étape est d'importer la bilbiothèque. Dans Python elles s'appellent des modules ou packages. Pour ce faire, la syntaxe est la suivante: from pypot.creatures import * L'étoile signifie \"tout\", ce qui veut dire que nous allons importer toutes les créatures Poppy installées sur votre ordinateur. Mais il est possible d'en improter qu'une seule ... ... par exemple celle de l'Ergo Jr : from pypot.creatures import PoppyErgoJr ... par exemple celle de Torso : from pypot.creatures import PoppyTorso ... par exemple celle d'Humanoid : from pypot.creatures import PoppyHumanoid Note Si une erreur similaire à cette capture d'écran apparaît (erreur nommée Import Error), alors votre installation des bibliothèque Python a probablement échoué. Reportez-vous à la section d'installation pour recommencer. In [1]: from pypot.creatures import PoppyHumanoid ImportError Traceback (most recent call last) in () ----> 1 from pypot.creatures import PoppyHumanoid ImportError: cannot import name PoppyHumanoid Créer l'objet \"Robot\" (avec un robot réel) L'objet Robot est celui qui représente votre robot en Pyton. Selon votre créature, vous devez créer un objet différent ... ... pour importer l'objet de l'Ergo Jr : poppy = PoppyErgoJr() ... pour importer l'objet de Torso : poppy = PoppyTorso() ... pour importer l'objet de l'Humanoid : # if you are using a Humanoid poppy = PoppyHumanoid() Si aucune erreur n'apparaît, alors votre interpréteur Python est correctement connecté. En revanche si une erreur similaire à ceci apparait, alors certains de vos moteurs (voire tous) sont peut-être mal connectés ou défecteueux. Vérifiez leur connectique et le schéma de montage. Note Lorsqu'elle survient, cette erreur vous indiquer le numéro du ou des moteur(s) posant problème entre les crochets, cela peut vous aider à situer la source du problème. IOError: Connection to the robot failed! No suitable port found for ids [3, 5, 7, 11, 13, 17]. These ids are missing [3, 5, 7, 11, 13, 17] ! Créer l'objet Robot - avec CoppeliaSim (V-REP) To use a simulated robot instead of a real one, you only have to specify it when creating the Robot object. For instance, if you want to create a simulated Poppy Torso, you simply have to execute the following line: poppy = PoppyTorso(simulator='vrep') All three Poppy robots - Humanoid, Torso, and Ergo Jr - can be used with CoppeliaSim. If you see an error message like this, check that you have launched CoppeliaSim and that you have close the popup in CoppeliaSim (see this chapter for details). IOError: Connection to CoppeliaSim failed! Create the Robot object - with web simulator Currently only the Ergo Jr is usable within the web simulator. It also requires specific versions of libraries to be used properly. To make sure you meet these requirements, you can type this command from your shell: pip install pypot>=2.12 poppy-creature>=1.8 poppy-ergo-jr>=1.6 --upgrade Vous pouvez ensuite instancier la créature poppy-ergo-jr : poppy-services --poppy-simu --snap --no-browser poppy-ergo-jr Cela va créer un serveur pour Snap ! sur port 6969 et un serveur pour le visualiseur sur le port 8080. Vous pouvez ensuite vous diriger vers la page du visualiseur. Accéder aux capteurs et aux moteurs L’objet robot que vous venez de créer contient deux groupes principaux d’objets : moteurs sensors auxquelles on peut facilement accéder à l’aide de poppy.motors et poppy.sensors. Dès que l’objet robot est créé, il débute automatiquement des boucles de synchronisation qui assurerons que les dernières valeurs disponibles sont reçus/envoyés au robot. Note Les servomoteurs qui sont utilisés dans des robots Poppy peuvent être considérés à la fois comme des moteurs ou des capteurs. Indeed, on top of being \"simple\" motors, they also provide multiple sensing information: their current position, speed and load but also their temperature, the current used... Yet, for simplification they are only available under the motor category. Get data from your robot Now that you have created your robot object, you can directly use Python to discover which motors are attached. Note In all examples below the results are shown for an ErgoJr. If you are using a Torso or a Humanoid you will see more motors with different names. For instance, to know how many motors your robot have you can execute: print(len(poppy.motors)) poppy.motors is actually a list of all motors connected to your robot. Thus, if you want to get the present position of all motors, you can do: for m in poppy.motors: print(m.present_position) Of course, you can also access a specific motor. To do that, you need to know the name for the motor you want to access. You can find this list in the assembly documentation of your robot. You can also get a list of all motors name directly from python: for m in poppy.motors: print(m.name) or using a motor pythonic expression: print([m.name for m in poppy.motors]) Then you can directly access the desired motor by its name: m = poppy.m3 or get its position: print(poppy.m3.present_position) The most common values for motors are: present_position present_speed * present_load Similarly, you can get data from your sensors. Depending on the Poppy robot you have different sensors available. You can get the list of all sensors in the exact same way you did for motors: print([s.name for s in poppy.sensors]) And then access a specific sensors by its name. For instance, to get an image from the camera of the Ergo Jr: img = poppy.camera.frame Note This section just presented some of the available values that you can get from your motors/sensors. They are many other - some are specific to a particular robot - we will present them through the different notebooks. Send motor commands Now that we have shown you how to read values from your robot, it is time to learn how to make it move! This is actually really similar to what you have just seen. Instead of getting the present_position of a motor you simply have to set its goal_position. But first, you have to make sure your motor is stiff, meaning that you cannot move it by hand. To do that we will turn off its compliancy. Assuming you have an Ergo Jr and want to make the motor m3 moves - feel free to use any other motor but make sure the motor can freely move without hurting any of your finger: poppy.m3.compliant = False The motor should now be stiff. And then, to make it move to its zero position: poppy.m3.goal_position = 0 Note: present_position and goal_position are actually two different registers. The first refers to the current position of the motor (read only) while the second corresponds to the target position you want your robot to reach. Thus, they can have different values while the motor is still moving to reach its goal_position. As a slightly more complex example we will make it go to 30 degrees then -30° three times: import time for _ in range(3): poppy.m3.goal_position = 30 time.sleep(0.5) poppy.m3.goal_position = -30 time.sleep(0.5) Note that after each new value set to goal_position we wait so the motor has enough time to actually reach this new position. Another way to do the same thing is to use the goto_position method: import time for _ in range(3): poppy.m3.goto_position(30, 0.5, wait=True) poppy.m3.goto_position(-30, 0.5, wait=True) As you can see, this method takes three arguments, the target position, the duration of the move and whether to wait or not the end of the motion. If you want to move multiple motors at the same time, you can simply do something like: for _ in range(3): poppy.m1.goal_position = -20 poppy.m3.goal_position = 30 time.sleep(0.5) poppy.m1.goal_position = 20 poppy.m3.goal_position = -30 time.sleep(0.5) or use a python dictionary storing the target position per motor you want to move, that can be given to the goto_position method: pos_1 = {'m1': -20, 'm3': 30} pos_2 = {'m1': 20, 'm3': -30} for _ in range(3): poppy.goto_position(pos_1, 0.5, wait=True) poppy.goto_position(pos_2, 0.5, wait=True) Note You can turn a motor back to its compliant mode (where you can freely move it) by setting its compliant register to True: poppy.m3.compliant = True Record and play motion by demonstration using primitives Pypot provides you with the primitive mechanism, which are simply pre-defined behaviors that can be attached to your robot. In this section, we will show you how to use some primitives already existing for recording and playing motions. You can also define your own primitive but this is out of the scope of this section, you will find details on how to do this in dedicated notebooks. Record a motion by demonstration Designing choreographies for your robot using goal_position or goto_position can be long and kind of troublesome. Fortunately, there is a much more efficient way of doing this: recording motions by directly demonstrating the move on the robot. This can be summarized into few steps: make the robot compliant so you can move it by hand start the recording actually moves the robot so it follows whatever move/choreography you can think of stop the recording And now to do that in Python: So, first we turn all motors of the robot compliants: for m in poppy.motors: m.compliant = True Info You can also record a movement with motors stiff (compliant = False), and moving them with goal_position or goto_position commands. Then, we have to include the primitive used for recording motion: from pypot.primitive.move import MoveRecorder To create this primitive, you have to give the following arguments: on which robot you want to use this primitive (this can be useful if you are working with multiple robot at a time - for instance you can record a move on a robot and at the same time make it reproduce by another one. the record frequency of the move you want to register: how many position per second will be recorded - the higher the more accurate the record will be but also more data will have to be processed - good values are usually between 10Hz and 50Hz. the motors that you want to record. you can record a move on a subpart of you robot, for instance only on the left arm. Here, we will record a move on the whole robot at 50Hz: record = MoveRecorder(poppy, 50, poppy.motors) Note We used poppy.motors to specify that we want all motors if you only want let's say the two first motors of an Ergo Jr you could have used [poppy.m1, poppy.m2] instead. Now it is time to record. As it can be hard to both move the robot and type Python command at the same time, we will make a small script, that: wait 5s so you can get ready to record start the record record for 10 seconds stop the records import time # Give you time to get ready print('Get ready to record a move...') time.sleep(5) # Start the record record.start() print('Now recording !') # Wait for 10s so you can record what you want time.sleep(10) # Stop the record print('The record is over!') record.stop() Now, you should have a move recorded. You can retrieve it from the recorder primitive: my_recorded_move = record.move and check how many positions where recorded: print(len(my_recorded_move.positions())) Replay recorded moves Now to play back recorded motions you have to use another primitive: MovePlayer from pypot.primitive.move import MovePlayer player = MovePlayer(poppy, my_recorded_move) As you can see, to create it you have to specify the robot (as for the MoveRecorder) and the move you want to play. Note Automatically all recorded motors become stiff to be able to play the move. Then, you can simply start the replay: player.start() And if you want to play it three times in a row: for _ in range(3): player.start() player.wait_to_stop() We use the wait_to_stop method to make sure we wait for the first move to finish before we start another. By default, playing a move we will not block to allow you to play multiple move in parallel. Write a simple sensori-motor loop Robotic is all about sensori-motor loops, meaning that motor commands will be more or less directly related to the sensor readings. In other terms the robot actions will be determined by what it perceives from its environment. Poppy libraries and more particularly pypot provides you with tools to easily write sensori-motor loops. We will show here a very simple example where some motor of an Ergo Jr will be controlled by the position of other motors in order to keep the head of the Ergo Jr straight. To do that, we will free the two first motors, so they can be moved by hand. Two other motors will try to lively compensate the motion applied on the free motors. We need few simple steps: read values from sensors (here the two free motors) compute command from those readings set new motor command go back to step 1. Note This example is designed for the Ergo Jr. It could be adapted to other Poppy robots, by changing the motors used. Yet, it is not that obvious which one to use to have a \"cool\" result. Demo version Before writing the sensori-motor loop, we will first set the Ergo Jr in a base position. from pypot.creatures import PoppyErgoJr jr = PoppyErgoJr() jr.goto_position({'m1': 0., 'm2': -60., 'm3': 55., 'm4': 0., 'm5': -55., 'm6': 60.}, 2., wait=True) Then, we make sure the moving speed of the motors are not too high to prevent shaky motions: for m in jr.motors: m.moving_speed = 250 Finally, we free the two first motors: jr.m1.compliant = True jr.m2.compliant = True Now, that everything is setup we write our very simple sensori-motor loop like this: import time while True: # Step 1 p1 = jr.m1.present_position p2 = jr.m2.present_position # Step 2 g1 = -p1 g2 = -p2 # Step 3 jr.m4.goal_position = g1 jr.m6.goal_position = g2 time.sleep(.02) Step 1: As you can see, here our readings step is simply to retrieve the present_position of the motors m1 and m2. Step 2: Here, we defined the base position so the motors m1/m4 and m2/m6 are parallel. Thus, to compensate the head position, we simply have to define the new motor goal position as the opposite of the read present position. Step 3: We simply set the goal position as the just computed command Those steps are included inside an infinite loop - with a time.sleep to avoid CPU overhead. Note To stop this while True loop, you will have to use the classical Ctrl-c, or use the stop button if you are running it through Jupyter. Now with a primitive But what about if you want to make this behavior an independent \"brick\" that you can start/stop on demand combine with other behaviors. Well, primitives are meant to do just that. There is two main types of primitive: Primitive and LoopPrimitive. The first one basically gives you access to just a run method where you can do everything you want on a robot. The second one as the name indicates is an infinite loop which calls an update method at a pre-defined frequency. In our case it is the more suited one. Here is the entire definition of this primitive: class KeepYourHeadStraight(LoopPrimitive): def setup(self): for m in self.robot.motors: m.compliant = False self.robot.goto_position({'m1': 0., 'm2': -60., 'm3': 55., 'm4': 0., 'm5': -55., 'm6': 60.}, 2., wait=True) for m in self.robot.motors: m.moving_speed = 250 self.robot.m1.compliant = True self.robot.m2.compliant = True def update(self): self.robot.m4.goal_position = -self.robot.m1.present_position self.robot.m6.goal_position = -self.robot.m2.present_position As you can see, there is two main parts. The setup method which defines what needs to be done to prepare the robot before starting the behavior - here simply puts it in its base position and turn on the compliance for the two first motors. And the update method which will be regularly called: here is where we put the actual code for the sensori-motor loop: reading sensor - computing the new command - and sending the new command to the motors. Now that we have defined our primitive, we can instantiate it and start it: # we specify we want the primitive to apply on the jr robot instance # and that the update method should be called at 50Hz head_straight = KeepYourHeadStraight(jr, 50.0) head_straight.start() You can stop it whenever you want: head_straight.stop() And re-starting it again... head_straight.start() The huge advantage of using a primitive in this case is that after starting it, you can still easily run any other codes that you want. The primitive starts its own thread and thus runs in background without blocking the execution of the rest of the code. Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"programming/rest.html":{"url":"programming/rest.html","title":"API des robots","keywords":"","body":"Use the REST API to control a Poppy Robot Attention Cette page est encore vierge. Votre aide est nécessaire pour la remplir ! Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"demo-activities/":{"url":"demo-activities/","title":"Activités","keywords":"","body":"Galerie d’activités Attention Cette page est encore vierge. Votre aide est nécessaire pour la remplir ! Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"demo-activities/snap4arduino.html":{"url":"demo-activities/snap4arduino.html","title":"Lien avec Snap4Arduino","keywords":"","body":"Contrôler Poppy avec un Arduino via Snap4Arduino Rédigé par Gilles Lassus. Objectif : contrôler un moteur de Poppy par un potentiomètre sur la platine Arduino. Préparation de Snap4Arduino Téléchargez et installez Snap4Arduino. Téléchargez les blocs pypot-snap-blocks.xml. Ils devront être importés dans Snap4Arduino à chaque démarrage. Préparation de l'Arduino Connectez votre platine, ouvrez Arduino et téléversez le firmware StandardFirmata. (disponible via Fichier - Exemples - Firmata). Branchez un potentiomètre sur la sortie analogique A0, comme illustré ci-dessous : Lancement de la simulation (dans le cas d'un Poppy simulé dans Vrep) Lancez CoppeliaSim. Exécutez les commandes python suivantes : from pypot.creatures import PoppyHumanoid poppy = PoppyHumanoid(simulator='vrep', use_snap=True) puis poppy.snap.run() Ouverture de Snap4Arduino Lancez Snap4Arduino et importez les blocs pypot-snap-blocks.xml. (une fenêtre avertissant que le projet importé a été créé par Snap! apparaît ; elle est sans conséquence.) Dans les blocs Arduino, cliquez sur Connect Arduino pour établir la connexion entre Snap4Arduino et votre platine. Un message de confirmation apparaît, signe que la connexion est effective. Commander un moteur via le potentiomètre La valeur analogique lue dans A0 est un entier entre 0 et 1024. Pour la \"mapper\" entre (environ) -40 et 40, on la divise par 12 avant de lui soustraire 40. On peut donc alors construire l'instruction suivante, qui fera bouger le moteur head_z de Poppy entre -40° et +40° : Remarques diverses Il peut être utile de créer un bloc map équivalent à la fonction éponyme d'Arduino, permettant de mettre à l'échelle automatiquement une valeur dans une plage donnée : Le script de commande du moteur head_z de Poppy entre -40° et 40° deviendrait alors : Cette méthode de contrôle a pour principal défaut de \"bloquer\" la carte Arduino avec le StandardFirmata : il serait plus agréable de pouvoir simplement lire les données du port série envoyées par l'Arduino, et ainsi pouvoir téléverser le programme de son choix dans l'Arduino. Ceci est discuté ici. Toutefois, la page du projet Snap4Arduino liste les composants annexes (LCD display, UltraSound Sensor) pouvant être directement contrôlés, et explique en détail comment modifier le StandardFirmata pour intégrer un nouveau composant. Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"from-simulation-to-real-robot/":{"url":"from-simulation-to-real-robot/","title":"De la simulation au robot tangible","keywords":"","body":"Passer du robot Poppy simulé au robot physique Un élément-clé du projet Poppy est de vous donner la possibilité de facilement passer d'un robot simulé (en utilisant CoppeliaSim par exemple) à un vrai robot. C'est assez utile lorsque vous : Développez une expérimentation dans laquelle vous pouvez tout configurer à partir de la simulation, pour la lancer ensuite sur le robot physique. Faites travailler vos élèves dans un premier temps sur des ordinateurs grâce à une simulation pour ensuite les faire essayer leurs travaux sur un robot physique partagé Cependant, même si c'est fait de façon à ce que passage d'un plan à l'autre soit aisé, il y a quelques points à assimiler. Une des différence majeure est que lorsque vous travaillez via la simulation, tout se fait depuis votre ordinateur alors que quand vous utilisez une robot physique, le logiciel (par exemple les Python Notebooks) tout se fait depuis le robot. Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"from-simulation-to-real-robot/using-jupyter.html":{"url":"from-simulation-to-real-robot/using-jupyter.html","title":"Programmer avec les notebooks Jupyter","keywords":"","body":"À l’aide des notebooks Jupyter en Python L'un des avantages de travailler avec les notebooks Jupyter est de pouvoir les utiliser dans une approche client/serveur.Chaque robot Poppy héberge un serveur Jupyter accessible via l'interface web (voir la section démarrage rapide pour plus de détails). Lorsque vous travaillez via une simulation, tout est géré et stocké sur votre ordinateur. Lorsque vous travaillez avec un robot physique vous pouvez le programmer depuis un navigateur web sur votre propre ordinateur, mais vos notebooks Jupyter sont en fait stockés et exécutés dans le robot. Donc pour passer de la simulation au robot physique, vous devez passer de votre instance locale Jupyter à l'instance hébergée par le robot. Les étapes sont décrites ci-dessous. Se connecter à Jupyter sur le robot Une fois connecté à l'interface web du robot http://poppy.local (nous supposerons ici que son nom d’hôte est poppy, remplacez-le par le nouveau nom d’hôte si vous l’avez changé), vous devriez voir un lien ouvrir notebook Ipython. Lorsque vous cliquez dessus, Jupyter démarre sur le robot et vous redirige vers le serveur Web Jupyter. Vous devriez alors voir la racine du dossier notebook hébergé sur le robot : C'est ici que vous pouvez mettre vos propre notebooks. Bien sûr vous pouvez créer des dossier, les organiser à souhait etc. Note : Si vous avez besoin d'un accès plus précis ou d'une configuration plus avancée (telle qu'une autorisation), vous devez vous connecter au robot directement en utilisant SSH. Télécharger un notebook Une fois connecté au serveur Jupyter hébergé par le robot, vous pouvez directement utiliser l’interface Jupyter pour le téléverser de nouveaux notebooks. Le bouton rond permet de télécharger votre notebook local, stocké sur votre propre ordinateur, au robot. Ils peuvent alors être directement exécuté sur le robot. Sachez que pour le moment, nous ne traitons pas avec des autorisations ou des sessions (comme JupyterHub par exemple), et donc toute personne ayant accès au robot peut utiliser ou supprimer tous notebooks stockés dans le robot. Adapter votre code Il y a peu d’endroits où vous devez réellement modifier votre code pour qu’il fonctionne avec un robot physique. Nous essayons de minimiser l’effort nécessaire dans la mesure du possible, cependant certaines étapes sont encore nécessaires. Instanciation Lorsque vous créez le robot, vous devez en fait préciser si vous êtes disposé à travailler avec un robot physique ou un robot simulé. Cela se fait simplement via un paramètre. Par exemple : En travaillant avec CoppeliaSim : from pypot.creatures import PoppyHumanoid poppy = PoppyHumanoid(simulator='vrep') En travaillant avec le robot physique : from pypot.creatures import PoppyHumanoid poppy = PoppyHumanoid() Bien évidemment, cela fonctionne pour tous les robots Poppy : Humanoid, Torso et Ergo Jr. Il s’agit de la plupart des modifications que vous aurez à faire. Les APIs spécifiques Une partie de l'API dépend des plateformes. Par exemple, en utilisant CoppeliaSim vous avez accès aux fonctionnalités de tracking qui vous permet de récupérer n'importe quelle position 3D de l'objet. Mais cette méthode n'a pas d'équivalent dans le monde réel et n'est donc pas réalisable avec un robot physique. Utiliser la propriété simulée est un bon entrainement si vous souhaitez écrire du code compatible pour les deux cas. Elle est automatiquement définie à la valeur correcte selon la façon dont vous instanciez votre robot. Par exemple, poppy = PoppyHumanoid(simulator='vrep') def reset_position(): if poppy.simulated: poppy.reset_simulation() else: print('Ask one internship student to put the robot back in its origin position.') time.sleep(10) Version et bibliothèques tierces Le principal inconvénient de travail avec le mode client/serveur est que les versions de vos logiciels installés localement peuvent différer de celui installé sur le robot. La version de Python installée sur le robot est Python 3 et dispose de la plupart des principales bibliothèques scientifiques (numpy, scipy, matplotlib, opencv). Une liste exhaustive des packages Python installés sera disponible bientôt . Pour le moment, le moyen le plus simple d'y parvenir est d’utilisé un terminal notebook qui peut être exécuté directement depuis l’interface de Jupyter. En utilisant la même technique, vous pouvez installer des bibliothèques tierces directement sur le robot. L' outils utilitaire pip est installé dans un environnement virtuel Python et devrait être utilisé lorsque cela est possible. Notez que la carte embarquée repose sur une architecture armv7 et donc certaines bibliothèques peuvent être difficiles à compiler. Nous maintenons une liste de recettes conda spécialement conçu pour cette plate-forme ici.Plus de contributions sont les bienvenues ! * Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"from-simulation-to-real-robot/using-snap.html":{"url":"from-simulation-to-real-robot/using-snap.html","title":"Snap! sur le robot tangible","keywords":"","body":"Avec Snap! Attention Cette page est encore vierge. Votre aide est nécessaire pour la remplir ! Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"software-libraries/":{"url":"software-libraries/","title":"Documentation des bibliothèques logicielles","keywords":"","body":"Software libraries This section will provide software documentation of various libraries used in Poppy robots. Pypot Poppy-creature Poppy Ergo Jr Poppy Humanoid Poppy Torso Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"software-libraries/pypot.html":{"url":"software-libraries/pypot.html","title":"Pypot","keywords":"","body":"Pypot library Caution Pypot documentation has still not been merged in the new documentation. You can find it at poppy-project.github.io/pypot/ Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"software-libraries/poppy-creature.html":{"url":"software-libraries/poppy-creature.html","title":"Poppy-creature","keywords":"","body":"Poppy-creature library Introduction Poppy-creature is a small library providing an abstract interface for robots (Poppy Humanoid, Poppy Torso, Poppy Ergo Jr...). It links high level controls and pypot, the generic low level library. It mainly contains the class definition of pypot.creatures.abstractcreature.AbstractPoppyCreature which takes a configuration and builds a pypot.robot.robot.Robot out of it, but also a bunch of parameters to launch Snap! or HTTP servers, or to replace the communication toward Dynamixel servos by a communication with a simulator. The arguments you can provide are: base_path default: None Path where the creature sources are. The librarie looks in the default PATH if not set. config default: None Path to the configuration file with respect to the base-path simulator default: None Possible values : 'vrep' or 'poppy-simu'. Defines if we are using a simulator (and which one) or a real robot. scene default: None Path to the scene to load in the simulator. Only if simulator is vrep. Defaults to the scene present in the creature library if any (e.g. poppy_humanoid.ttt). host default: 'localhost' Hostname of the machine where the simulator runs. Only if simulator is not None. port default: 19997 Port of the simulator. Only if simulator is not None. use_snap default: False Should we launch the Snap! server snap_host default: 0.0.0.0 Hostname of the Snap! server snap_port default: 6969 Port of the Snap! server snap_quiet default: True Should Snap! not output logs use_http default: False Should we launch the HTTP server (for http_host default: 0.0.0.0 Hostname of the HTTP server http_port default: 8080 Port of the HTTP server http_quiet default: True Should HTTP not output logs use_remote default: False Should we launch the Remote Robot server remote_host default: 0.0.0.0 Hostname of the Remote Robot server remote_port default: 4242 Port of the Remote Robot server sync default: True Should we launch the synchronization loop for motor communication The sources are available on GitHub. Poppy services Poppy-creature also provides a command line utility poppy-services. It provides shortcuts to start services like SnapRemoteServer and HTTPRemoteServer from your terminal. Example: poppy-services poppy-ergo-jr --snap --no-browser This will launch the SnapRemoteServer for a real Poppy Ergo Jr robot. Note The --no-browser option avoid the automatic redirection to the Snap! webpage. You can remove it if you use a computer with a GUI (e.g your laptop instead of the robot embedded board). Another example: poppy-services poppy-ergo-jr --snap --poppy-simu It will open a Snap! windows for a simulated poppy-ergo-jr. The way to use it is: poppy-services the available options are: --vrep: creates the specified creature for using with CoppeliaSim simulator --poppy-simu: creates the specified creature for using with web simulator and also launches the HTTP server needed by poppy-simu. Poppy-simu is only available for poppy-erg-jr for now. --snap: launches the Snap! server and directly imports the specific Poppy blocks. -nb or --no-browser: avoid automatic start of Snap! in web browser, use only with --snap --http: start a http robot server --remote: start a remote robot server -v or --verbose: start services in verbose mode (more logs) Create your own Poppy creature While developping a new Poppy creature, it is first easier to simply define it in a configuration file or dictionnary and instanciate a pypot.robot.robot.Robot from Pypot directly. But when you want to make it easily usable and available to non-geek public, the best is to create your own creature's library. It should contain a configuration file and a class that extends pypot.creatures.abstractcreature.AbstractPoppyCreature. You can then add your own properties and primitives. Example from Poppy Humanoid: class PoppyHumanoid(AbstractPoppyCreature): @classmethod def setup(cls, robot): robot._primitive_manager._filter = partial(numpy.sum, axis=0) for m in robot.motors: m.goto_behavior = 'minjerk' for m in robot.torso: m.compliant_behavior = 'safe' # Attach default primitives: # basic primitives: robot.attach_primitive(StandPosition(robot), 'stand_position') robot.attach_primitive(SitPosition(robot), 'sit_position') # Safe primitives: robot.attach_primitive(LimitTorque(robot), 'limit_torque') Package your code it properly using setuptools. For a better integration with the Poppy installer scripts, please have in the root of your repo a folder named software containing: the installation files (setup.py, MANIFEST, LICENCE) a folder named poppy_yourcreaturename containing your actual code At the end, don't forget to share it to the community! Most interesting creatures will be added to this documentation! Installing Info poppy-creature library is a dependancy of any Poppy robots libraries, so you don't have to install it by hand in a normal case. To install the poppy-creature library, you can use pip: pip install poppy-creature Then you can update it with: pip install --upgrade poppy-creature If you prefer to work from the sources (latest but possibly unstable releases), you can clone them from GitHub and install them with (in the software folder): python setup.py install Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"software-libraries/poppy-ergo-jr.html":{"url":"software-libraries/poppy-ergo-jr.html","title":"Poppy Ergo Jr","keywords":"","body":"Poppy-ergo-jr library Caution This section need to be completed, contribution are welcome ! Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"software-libraries/poppy-humanoid.html":{"url":"software-libraries/poppy-humanoid.html","title":"Poppy Humanoid","keywords":"","body":"Poppy-humanoid library Caution This section need to be completed, contribution are welcome ! Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"software-libraries/poppy-torso.html":{"url":"software-libraries/poppy-torso.html","title":"Poppy Torso","keywords":"","body":"Poppy-torso library Caution This section need to be completed, contribution are welcome ! Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"appendix/faq.html":{"url":"appendix/faq.html","title":"Résolution des problèmes","keywords":"","body":"Résolution des problèmes Problème 1 : poppy.local ne se charge pas (procédure de diagnostic) C'est l'erreur la plus manifeste que vous n'arrivez pas à utiliser votre robot : taper http://poppy.local dans votre navigateur aboutit à une erreur indiquant que le site web ne peut être chargé. Par exemple : La difficulté de cette erreur est qu'elle peut avoir de multiples causes. Mais pas d'inquiétude, voici une procédure pour vous aider à trouver la source du problème : I. Faire un test ping Un \"ping\" est tout simplement une tentative de connexion au robot, qui répondra avec un \"pong\". Ce qui permet ensuite de mesurer diverses statistiques de temps de communication. Connectez votre robot avec un cable Ethernet soit directement ou au travers d'un routeur/box, et branchez l'alimentation pour que votre robot démarre Ouvrez un terminal : sur Windows pressez la touchez \"Windows\" ç gauche de la barre d'espace et tapez \"cmd\" dans le champs de recherche qui apparait puis validez par Entrée. Sur GNU/Linux ou OSX, une application spéciale nommée Terminal peut facilement être trouvée dans la liste des applications ou les menus Vous optenez une fenêtre, généralement sur fond sombre et un invite de commande qui mentionne votre nom d'utilisateur et le nom de votre ordinateur. A la suite de l'invite de commande, tapez ping poppy.local puis appuyez sur Entrée. En réponse, chaque second, une nouvelle ligne s'affiche à l'écran, telles que : Selon votre système d'exploitation et votre réseau, le look de la fenêtre, les adresses IP et les délais peuvent largement varier par rapport à la capture d'écran ci-dessus. Le plus improtant est d'identifier si chaque ligne mentionne des délais de communication en millisecondes. Si oui, alors le test ping est réussi, comme dans la capture d'écran. Dans ce cas, l'adresse IP entre parenthèses à côté du nom du robot est l'adresse IP actuelle de votre robot. Attention, cette adresse IP peut changer d'un jour à l'autre alors que poppy.local ne change jamais, à moins que vous changiez le nom de votre robot dans les paramètres. Si le test est réussi, passez à la section II.A. Sinon, une erreur est probablement affichée à la place, indiquant que la tentative de communication a échoué, dans ce cas consultez II.B.. Avec Windows, un test ping s'arrête automatiquement après 4 lignes. Sur GNU/Linux et OSX, de nouvelles lignes s'affichent sans arrêt. Vous pouvez les arrêtez en pressant simultanément Ctrl + C ou bien en fermant la fenêtre. II.A. Si le test ping réussit Si le test ping réussit mais que vous ne pouvez toujours pas charger http://poppy.local dans votre navigateur, alors le problème vient du côté du navigateur. Vérifiez que vous n'oubliez pas le préfix http://. Ce préfixe s'assure qu'une connexion normale au robot est établie. Les navigateurs modernes forcent parfois une connexion sécurisée en le remplaçant par https://. Cependant les connexion sécurisées ne fonctionnent que lorsque vous êtes sur Internet. Vous pourriez rencontrer des problèmes de cache, appuyez sur Ctrl + Maj + R dans votre navigateur pour forcer le rechargement de la page sans cache. Essayez un autre navigateur : Mozilla Firefox, Chromium, Safari, Opera, Microsoft Edge, Google Chrome... En dernier recours, il est possible que le logiciel Poppy ne parvienne pas à démarrer, dans ce cas il est recommandé de re-flasher votre carte SD. II.B. Si le test ping échoue Si le test ping échoue vous rencontrez un problème de communication : votre ordinateur n'arrive pas à contacter le robot ! Déconnectez l'alimentation du robot branchez-la de nouveau en prêtant une attention particulière aux LED rouges et vertes de la Raspberry Pi : La LED PWR (Power) doit être rouge en continu 🔴 et la LED ACT (activity) verte 🟢 doit vaciller de manière irrégulière pendant environ 45 secondes, signifiant que le robot est en train de démarrer. Continuez avec A, B, C, ou D selon votre situation : A. Si PWR n'est pas rouge fixe 🔴 : vous avez un problème d'alimentation. Sur un robot Ergo Jr, vous pourriez avoir mal enfiché la carte Pixl, vérifiez que vous avez bien respecté la procédure d'assemblage électronique. Sinon, votre carte Pixel ou votre Raspberry Pi pourraient être défectueuse. Tentez d'échanger ces composants avec d'autres robot si vous en avez, ou contactez votre fournisseur. B. Si la LED verte ACT reste éteinte, alors le systèem sur la carte SD est probablement endommagé, ou bien la carte SD elle-même, ou bien la Raspberry Pi. Testez d'abord de re-flasher la carte SD, ensuite essayez de flasher et utiliser une autre carte SD, et en dernier recours essayez une autre Raspberry Pi. C. Si la LED verte ACT 🟢 clignote de façon régulière comme une séquence de flashs longs et courts, cette séquence vous donne des indices sur l'origine du problème, veuillez dans ce cas consultez la documentation appropriée. D. Si la LED verte ACT 🟢 vacille de manière irrégulière pendant environ 45 secondes, puis s'éteint quasi homris des flash ponctuels, cela signifie que le robot démarre normalement. Votre problème dans ce cas est d'ordre réseau. Le mode de connexion que vous utilisez (wifi, Ethernet direct, Ethernet via un routeur/box, ou hostpot) pourrait ne pas fonctionner dans votre situation. Une bonne idée dans ce cas est de se replier sur la méthode de conneixon la plus simple possible : avec un câble Ethernet au travers d'un routeur ou d'une box, ce qui nécessite 2 câbles Ethernet : l'un de votre robot à votre routeur/box, l'autre de votre ordinateur à votre routeur/box. Ensuite suivez de nouveau la procédure de diagnostic. Problème 2 : Les mouvements de mon robot sont saccadés Ceci est souvent dû à des câbles déteriorés. C'est d'autant plus flagrant si vous sentez en les manipulant que les câbles sont rigides par rapport à des câbles neufs, alors qu'ils devraient être souples. Ceci cause des problèmes de communication. Changez les câbles par des câbles neufs. Problème 3 : Mon robot fait des mouvements bizarres ou s'auto-collisionne Si votre robot fait des mouvements qui ne correspondent pas à ce que vous attendez ou qui font que poppy s'auto-collisionne, c'est probablement que vous avez assemblé votre robot à l'envers. Reprenez chacune des étapes une par une et vérifiez attentivement que votre les pièces de votre robot sont en tout point positionnées identiquement au photos ou schémas. Il est assez facile de se tromper et d'obtenir un robot qui a l'air bien assemblé, alors qu'il ne l'est pas. Problème 4 : Quels est le mot de passe SSH par défaut de mon robot ? Un mot de passe est demandé exclusivement pour l'accès à votre robot via SSH, pour les utilisateurs avancés. Avec l'image Poppy standard, le nom d'utilisateur est poppy et son mot de passe est poppy. Avec l'image ROS, le nom d'utilisateur est pi et son mot de passe est raspberry. Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "},"appendix/contribute.html":{"url":"appendix/contribute.html","title":"Contribuez","keywords":"","body":"Contribuer au Projet Poppy Si vous voulez faire partie du projet, la première étape est de devenir membre de la communauté sur le forum Poppy. Le forum est l'espace consacré aux échanges entre les utilisateurs et les contributeurs. Vous êtes invités à partager votre projet et vos idées dans votre langue préférée. Le projet Poppy étant un projet pluridisciplinaire, il y a plusieurs façons d'apporter sa contribution : En sciences de l’ingénierie telles que l'IA, l'informatique, la mécanique, l'électronique, apprentissage automatique... En sciences humaines, telles que les sciences cognitives, la psychologie... En sciences de la vie telles que la biologie, la biomécanique... Dans le domaine de la gestion de communauté, de la médiation scientifique, de la communication... En design, tel qu'en web design, design interface ou amélioration de l'expérience utilisateur... Des profils artistiques pour la conception d'animations qui recréent des mouvements réalistes et des émotions. Si vous n'avez aucune idée de comment contribuer mais que vous en avez la volonté, nous vous invitons à jeter un coup d'oeil aux \"issues\" ouvertes sur notre GitHub et aux appels à contribution. Pour les ninjas du GitHub, vous pouvez bien sûr créer des tickets pour signaler un problème ou développer de nouvelles fonctionnalités époustouflantes et ouvrir des pull requests pour demander à intégrer votre idée. Des questions ? Nous sommes toujours heureux de vous aider sur un problème de programmation ou sur tout autre question que vous pourriez avoir ! N'hésitez pas à poser vos questions et partager des solutions sur notre forum communautaire. "}}